# 原型
## 原型的定义
  1. 显示原型对象(函数)

    -  每个函数都有一个属性prototype，该属性指向的是一个空的Object实例对象,js引擎会自动给该对象添加一个constructor属性
  2. 隐式原型对象(实例对象)

    -  每一个实例对象身上都有一个__proto__的属性,该属性指向的也是一个对象


​    
## 为什么要设计原型
  1. 节省内存空间
  2. 节省代码量
  3. 实现继承


## 原型链
  1. 查找对象的属性的时候先在自身找
  2. 如果自身没有，沿着__proto__这条链查找
  3. 直到找到Object的显示原型对象
  4. 如果还没有返回undefined
  5. __proto__这条链就是原型链

## 理解 函数对象 概念
  1. 函数是特殊的对象
  2. 和普通对象的区别是函数可以调用，具备行为


## instanceof 运作原理
  1. A instanceof B 判断A是否是B的实例
  2. 判断的依据： B.prototype是否出现在A的原型链上，只要出现判断结果就是true


## 变量提升(预解析)
  1. js引擎在代码正式执行之前会做一些预解析的工作

    -  找关键字 var function
    -  找到var将var后边的变量提前声明，但是不赋值 var a;
    -  找到function以后提前 定义 该函数
  2. 效果

    -  在var语句之前可以访问var后边的变量不会报错，但是值是undefined
    -  在函数体之前可以调用该函数
  3. 特例：

    - 函数和变量同名的时候预解析的结果永远是函数
    - 原因： 
      -  function的优先级高于var
      -  顺序预解析： 个人理解

# 执行上下文 
## 执行上下文环境
  1. js引擎在代码正式执行之前先创建环境(执行上下文环境)，并进入
  2. 进入环境之后会做以下事情

    -  创建一个空对象(执行上下文对象)
    -  该对象用于收集：变量，函数，函数的参数 ---> 变量提升
    -  确认this的指向： 全局： this ---> window(全局的执行上下文对象)， 局部：this ---> 调用函数的对象
    -  创建作用域链

  3. 特殊

    -  函数的局部执行上下文对象没有可见指针
    -  函数预解析的时候遇到function会先去找是否调用再决定是否定义内部函数


## 执行上下文对象
  -  创建一个空对象(执行上下文对象)

## 执行上下文栈
  1. 先进后出
  2. 后进先出

  

# 作用域
## 作用域定义
  -  代码作用的范围
## 作用域的作用
  -  隔离变量
## 作用域什么时候产生
  -  代码定义的时候产生

## 作用域链
  -  当查找变量的时候现在自身所处的作用域的执行上下文对象去找
  -  如果没有去外层作用域的执行上下文对象去找
  -  知道找到全局的执行上下文对象，如果还没有报错： xxx is not defined

  

# 闭包
## 闭包产生的条件
  1. 函数嵌套
  2. 内部函数引用外部函数的局部变量

## 闭包的特点
  1. 闭包就是一个对象: {key: value}
  2. 保存在内部函数中

## 闭包的作用 || 优点
  1. 延长外部函数局部变量（内部函数牵引的变量）的生命周期
  2. 可以在外部访问函数内部的局部变量
## 闭包的缺点
  1. 闭包如果不及时清除的话会长期占用内存
  2. 多次使用闭包的话容易造成内存溢出
## 使用闭包的时候注意什么
  1. 能不用就不用
  2. 用完及时清除闭包
  ```
   function fun() {
      var num = 123;
      var a = 'abc';
      function fun2() {
        console.log(num);
      }
      return fun2;
    }
  
    var fun2 = fun();
    fun2();
    fun2 = null;
    
  ```

## 闭包的使用场景
  1. 循环遍历加监听
  2. 在函数的外部需要操作函数内部的局部变量的时候
  3. 封装js功能库的时候
  4. React 和 Vue中在组件的生命周期函数里一定有闭包，局部变量指的是this或者其他


## 事件循环机制
  1. js是单线程的，所有的代码都会在js的主线程执行
  2. 异步任务(定时器，事件的回调，网络请求)不会立马执行结束，会交由对应的管理模块去管理
  3. 对应的管理模块在异步任务满足条件之后将对应的回调函数放在callback queue中
  4. 主线程上同步任务执行完毕会询问callback queue中是否有可执行的回调，如果有，就将回调函数钩出去放在主线程执行
  5. 主线程上的代码执行结束后会反复的去问，又叫event loop ----> 事件轮询机制

  


# 重要概念
  原型，作用域，闭包，继承，this，执行上下文
  # 作用域

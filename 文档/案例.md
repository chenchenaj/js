# vue2

## 登录后跳转回原界面

route

```js
router.beforeEach((to, from, next) => {
  if (from.name == 'Login') {
    // 如果不需要权限校验，直接进入路由界面
    next()
  } else if (to.meta.requireAuth) {
    // 判断该路由是否需要登录权限
    if (localStorage.getItem('token')) {
      // 获取当前的token是否存在
      next()
    } else {
      alert('请登录后再访问')
      next({
        path: '/login', // 将跳转的路由path作为参数，登录成功后跳转到该路由
        query: { redirect: to.fullPath },
      })
    }
  } else {
    // 如果不需要权限校验，直接进入路由界面
    next()
  }
})
```

login

```js
// 	请求结束后，判断地址栏是否有跳转地址，如果有跳转到对应页面，没有则跳转至首页
if (this.$route.query.redirect) {
  //如果存在参数
  let redirect = this.$route.query.redirect
  this.$router.replace(redirect) //则跳转至进入登录页前的路由
} else {
  this.$router.replace('/') //否则跳转至首页
}
```

## 401 错误

需结合 `router.beforeEach` 使用

```js
axios.interceptors.request.use((config) => {
  // 将json格式请求体转换为urlencode
  const { method, data } = config
  if (method.toLowerCase() === 'post' && data instanceof Object) {
    // 此处要转成urlencode模式，不是转成对象模式
    config.data = qs.stringify(data)
  }

  // 判断页面是否需要携带token才能请求
  if (config.headers.needToken) {
    const token = JSON.parse(localStorage.getItem('token_key'))
    if (token) {
      config.headers.Authorization = token
    }
  }
  return config
})

// Add a response interceptor
axios.interceptors.response.use(
  (response) => {
    //直接返回，作为下一个成功结果的回调
    return response.data
  },
  (error) => {
    // 判断是什么错误
    const { response, message } = error
    // 1. token超时
    if (response.status === 401) {
      // 调用退出登录的方法
      store.dispatch('resetUser')
      if (router.currentRoute.path !== '/login') {
        Toast(message)
        router.push('/login')
      }
    }

    // 2. 一般请求错误
    else {
      Toast('请求错误' + message)
    }

    return new Promise(() => {})
  }
)

axios.interceptors.response.use(
  function (response) {
    return response
  },
  function (error) {
    if (error.response.status == 401 || error.response.status == 402) {
      router.push('/login')
      Vue.prototype.$msg.fail(error.response.data.message)
    }
    return Promise.reject(error)
  }
)
```

## router 页面使用封装的组件

router.js

```js
import { Toast } from 'mint-ui
Toast(message)
```

或

main.js

```js
import vant from 'vant'
import { Toast } from 'vant'
import 'vant/lib/index.css'
Vue.prototype.$msg = Toast
```

router.js

```js
Vue.prototype.$msg.fail(error.response.data.message)
```

## 记住密码

![1590388030771](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1590388030771.png)

**功能**

1.记住密码勾选，点登陆时，将账号和密码保存到 cookie，下次登陆自动显示到表单内 2.不勾选，点登陆时候则清空之前保存到 cookie 的值，下次登陆需要手动输入

> 通过存/取/删 cookie 实现的；每次进入登录页，先去读取 cookie，如果浏览器的 cookie 中有账号信息，就自动填充到登录框中，存 cookie 是在登录成功之后，判断当前用户是否勾选了记住密码，如果勾选了，则把账号信息存到 cookie 当中，效果图如上：

需要安装 `js-base64` 包

```shell
npm install --save js-base64
```

实现代码

```vue
<template>
  <form class="main">
    <!-- 账号 -->
    <div class="item">
      <label for="account">账号</label>
      <input type="text" style="display:none" />
      <input type="text" v-model="loginForm.account" id="account" />
    </div>
    <!--密码-->
    <div class="item">
      <label for="password">密码</label>
      <input type="password" style="display:none" />
      <input type="password" v-model="loginForm.password" id="password" />
    </div>
    <!-- 记住密码 -->
    <div class="item">
      <label>记住密码</label>
      <input type="checkbox" v-model="loginForm.remember" />
    </div>
    <!--登录按钮-->
    <button @click="submit">登录</button>
  </form>
</template>

<script>
// 引入base64
import { Base64 } from 'js-base64'
export default {
  data() {
    return {
      // 登陆表单
      loginForm: {
        account: '',
        password: '',
        remember: '',
      },
    }
  },
  created() {
    // 在页面加载时从cookie获取登录信息
    let account = this.getCookie('account')
    let password = Base64.decode(this.getCookie('password'))
    // 如果存在赋值给表单，并且将记住密码勾选
    if (userName) {
      this.loginForm.account = account
      this.loginForm.password = password
      this.loginForm.remember = true
    }
  },
  methods: {
    // 登录
    submit: function () {
      // 点击登陆向后台提交登陆信息
      axios.post('url', this.loginForm).then((res) => {
        // 储存token（需要封装拦截器，将token放入请求头中）
        this.setCookie('token', res.token)
        // 跳转到首页
        this.$router.push('/Index')
        // 储存登录信息
        this.setUserInfo()
      })
    },
    // 储存表单信息
    setUserInfo: function () {
      // 判断用户是否勾选记住密码，如果勾选，向cookie中储存登录信息，
      // 如果没有勾选，储存的信息为空
      if (this.loginForm.remember) {
        this.setCookie('account', this.loginForm.account)
        // base64加密密码
        let passWord = Base64.encode(this.loginForm.password)
        this.setCookie('remember', remember)
      } else {
        this.setCookie('account', '')
        this.setCookie('password', '')
      }
    },
    // 获取cookie
    getCookie: function (key) {
      if (document.cookie.length > 0) {
        var start = document.cookie.indexOf(key + '=')
        if (start !== -1) {
          start = start + key.length + 1
          var end = document.cookie.indexOf(';', start)
          if (end === -1) end = document.cookie.length
          return unescape(document.cookie.substring(start, end))
        }
      }
      return ''
    },
    // 保存cookie
    setCookie: function (cName, value, expiredays) {
      var exdate = new Date()
      exdate.setDate(exdate.getDate() + expiredays)
      document.cookie = cName + '=' + decodeURIComponent(value) + (expiredays == null ? '' : ';expires=' + exdate.toGMTString())
    },
  },
}
</script>

<style>
.main {
  width: 300px;
}
.main .item {
  display: flex;
  align-items: center;
  line-height: 30px;
}
.main .item label {
  width: 100px;
}
input:-webkit-autofill {
  -webkit-box-shadow: 0 0 0px 1000px white inset; //使用足够大的纯色内阴影覆盖黄色背景
  border: 1px solid #ccc !important;
}
</style>
```

## tabbar 封装

```vue
<template>
  <footer class="footer_guide">
    <span class="guide_item" :class="{ on: $route.path === '/video' }" @click="goTo('/video')">
      <span class="item_icon">
        <i class="fas fa-video"></i>
      </span>
      <span>视频</span>
    </span>
    <span class="guide_item" :class="{ on: $route.path === '/music' }" @click="goTo('/music')">
      <span class="item_icon">
        <i class="fas fa-music"></i>
      </span>
      <span>音乐</span>
    </span>
    <span class="guide_item" :class="{ on: $route.path === '/profile' }" @click="goTo('/profile')">
      <span class="item_icon">
        <i class="fas fa-user"></i>
      </span>
      <span>我的</span>
    </span>
  </footer>
</template>

<script>
export default {
  data() {
    return {}
  },
  methods: {
    goTo(path) {
      // 编程式路由导航
      this.$router.replace(path)
    },
  },
}
</script>
<style lang="less" scoped>
.footer_guide {
  border-top: 1px solid #ccc;
  position: fixed;
  z-index: 100;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #fff;
  width: 100%;
  height: 50px;
  display: flex;
  .guide_item {
    display: flex;
    flex: 1;
    text-align: center;
    flex-direction: column;
    align-items: center;
    margin: 5px;
    color: #999999;
    &.on {
      color: #02a774;
    }
    span {
      font-size: 12px;
      margin-top: 2px;
      margin-bottom: 2px;
      .iconfont {
        font-size: 22px;
      }
    }
  }
}
</style>
```

## navbar 封装

```vue
<template>
  <div class="navbar">
    <div class="left">
      <slot name="left"></slot>
    </div>
    <div class="center">
      <slot name="center"></slot>
    </div>
    <div class="right">
      <slot name="right"></slot>
    </div>
  </div>
</template>
<script>
export default {}
</script>
<style lang="less" scoped>
.navbar {
  display: flex;
  height: 44px;
  line-height: 44px;

  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 999;

  text-align: center;

  .left,
  .right {
    width: 60px;
  }
  .center {
    flex: 1;
  }
}
</style>
```

## Vue-Toast 插件封装

toast 文件夹的`Toast.vue`页面

```vue
<template>
  <div id="toast">
    <transition name="toast">
      <div class="toast_div" v-show="isShowTip">{{ message }}</div>
    </transition>
  </div>
</template>
<script>
export default {
  data() {
    return {
      isShowTip: false,
      message: '',
    }
  },
  methods: {
    show(msg, delay = 1000) {
      this.isShowTip = true
      this.message = msg
      setTimeout(() => {
        this.isShowTip = false
      }, delay)
    },
  },
}
</script>
<style scoped>
/**
* 给加入购物车做样式即过渡
*/
.toast_div {
  font-size: 0.8rem;
  text-align: center;
  line-height: 2rem;
  height: 2rem;
  width: 10rem;
  background-color: rgba(29, 24, 24, 0.9);
  border-radius: 0.4rem;
  border: 0.04rem solid rgba(0, 0, 0, 0.4);
  color: white;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
.toast-enter,
.toast-leave-to {
  opacity: 0;
}
.toast-enter-active {
  transition: opacity 1s;
}
.toast-leave-active {
  transition: opacity 1s;
}
</style>
```

toast 文件夹`index.js`页面

```js
const obj = {}

import Toast from './Toast.vue'

obj.install = function (Vue) {
  //创建组件构造器
  const toastConstructor = Vue.extend(Toast)

  //通过构造器创建组件实例
  const toast = new toastConstructor()

  //将实例挂载到元素上，并添加到DOM中
  toast.$mount(document.createElement('div'))

  document.body.appendChild(toast.$el)

  //给Vue原型添加上挂载后的实例
  Vue.prototype.$toast = toast
}

export default obj
```

`main.js`文件夹引入注册

```js
import Toast from 'components/common/toast/index.js'
Vue.use(Toast)
```

组件中使用

```js
this.$toast.show('加入购物车')
```

## tabs 切换

tabs 标签横向或不用随着滚动条的高度变化而变化

```js
<li v-for="(item, index) in menu" :key="index" :class="index === currentIndex ? 'current' : ''">

export default {
  data() {
    return {
      currentIndex: 0
    };
  },
  methods: {
    changeIndex(index){
      this.currentIndex = index
      this.$emit('changeTab', index)
    }
  },
};
```

tabs 标签纵向并且需要随着高度的变化而切换

```js
<li v-for="(item, index) in menu" :key="index" :class="index === currentIndex ? 'current' : ''">

computed: {
    // 当前的选中的li
    currentIndex(){
      const index = this.tops.findIndex((item,index) => this.scrollY>=item && this.scrollY < this.tops[index+1])
      // 右侧滑动，左侧的样式还会发生改变，显示根据下标的改变来知道样式的改变
      if(index !== this.index && this.leftScroll){
        this.index = index
        // 左侧列表选中项滑到顶部
        const li = this.$refs.leftUl.children[this.index]
        this.leftScroll.scrollToElement(li, 500)
      }
      return index
    }
  },
```



## 确定值的Boolean

控制台输入确定

```plain
Boolean({}) --true
Boolean(null) --false
```

## 取值属性名

发现属性名很怪异的时候，需要通过 [] 包裹并结合""来取值

```plain
const scopeAddress = result.authSetting["scope.address"]
```

出现这种错误可以尝试try..catch..

```plain
Uncaught (in promise) thirdScriptError
{"errMsg":"chooseAddress:fail auth deny"}
Object
```

## 全选every

```javascript
cart 数组     checked 数组中的属性
const allCheck = cart.every(item => item.checked) // 返回true或false
```

## 从缓存中获取数据

如果是数组，没有的时候需要加[]

如果是对象或则字符串则可以不用加

```plain
const address = wx.getStorageSync("address")
const cartList = wx.getStorageSync(("cart")) || []
```

## 时间

```plain
var date = new Date(); //Wed May 06 2020 21:17:10 GMT+0800 (中国标准时间)
console.log(date.valueOf()); // 1588770609353
console.log(date.toString()); // Wed May 06 2020 21:18:00 GMT+0800 (中国标准时间)
console.log(date.toLocaleString()); //2020/5/6 下午4:48:41
标准时间转字符串【不会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-5-14'
new Date().toLocaleDateString().replace(/\//g,'-') 
标准时间转字符串【会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-05-14'
const y = new Date().getFullYear()
const m = (new Date().getMonth() + 1 + '').padStart(2, '0')
const d = (new Date().getDate() + '').padStart(2, '0')
const timer = y + '-' + m + '-' + d
标准时间转字符串【不会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-5
字符串转标准时间 
'2020-5-14' => Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间)
new Date('2020-5-14')
```

```js
this.setData({
  // 先将里面的数组结构出来，然后新增一个可以转换时间格式的属性
  orderList: result.orders.map(item => ({...item, create_time_cn:(new Date(item.create_time*1000).toLocaleString())}))
})
```

## 计算机票时间

如果第二天的时间为01:00，前一天的时间为23:00，相减会变负数；

解决办法：判断第二天的时间是否小于前一天的时间，如果小于那么就 +24

```js
computed: {
    rankTime(){
        // 如果接口还没有请求回来时候，先返回空
        if(!this.data.arr_time) return "";
        // 到达时间
        const arr = this.data.arr_time.split(":"); // [18, 30]
        const dep = this.data.dep_time.split(":"); // [16, 00]

        // 如果到达的小时小于出发时间的小时，说明到了第二天凌晨
        if(arr[0] < dep[0]){
            arr[0] = +arr[0] + 24;
        }
        // 到达和出发时间转换成分钟
        const end = arr[0] * 60 + +arr[1];
        const start = dep[0] * 60 + +dep[1];
        // 间隔分钟
        const dis = end - start; // 150
        // 小时
        const hours = Math.floor(dis / 60)
        // 分钟
        const min = dis % 60;
        return `${hours}时${min}分钟`;
    }
},
```



## 前台分页分段显示

前台分页：即一次请求就请求回来所有的数据

后台分页：每次只会请求会当前页的数据回来

前台分页的分段显示 ======》 需要将请求回来的数组切割成显示的段，例：第一页【0-9】，第二页【10-19】

如果需要过滤数据，不需要重新发送请求给后台，直接在前台处理数据https://www.bilibili.com/video/BV1ZC4y1s7US?p=70

```vue
https://www.bilibili.com/video/BV1ZC4y1s7US?p=63
<template>
  <div>
    <!-- flightsData.flights是航班的列表 -->
    <FlightsItem 
    v-for="(item, index) in dataList"
    :key="index"
    :item="item"/>

    <!-- 分页组件 -->
    <!-- size-change: 切换条数时候触发的事件 -->
    <!-- current-change：页数切换时候触发的事件 -->
    <!-- current-page: 当前页数 -->
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="pageIndex"
      :page-sizes="[5, 10, 15, 20]"
      :page-size="pageSize"
      layout="total, sizes, prev, pager, next, jumper"
      :total="total"
    >
    </el-pagination>
  </div>
</template>

<script>
export default {
  name: "",
  data() {
    return {
      fightData: {}, // 总数据
      // 分页的变量
      pageIndex: 1,
      pageSize: 5,
      total: 0,
      dataList: [] // 存放当前页数据
    };
  },
  methods: {
    // 发送请求获取数据
    getData(){
      // 总数据
      this.filgthsData = res.data
      // 显示第一页的五条数据
      this.dataList = this.filgthsData.flight.slice(0,5)
    },
    // 分页切换条数时候触发
    handleSizeChange(val) {
      // 修改显示的条数
      this.pageSize = val;
      // 重新加载数据
      this.setDataList()
    },

    // 切换页数时候触发
    handleCurrentChange(val) {
      // 修改当前的页面
      this.pageIndex = val
      // 重新加载数据
      this.setDataList()
    },

    // 设置机票列表的数据
    setDataList(arr){
      // 在总列表中截取出当前页的数据
      this.dataList = this.filgthsData.filghts.slice((this.pageIndex - 1) * this.pageSize,this.pageIndex * this.pageSize)
    }
  }
};
</script>
<style lang="less" scoped></style>
```



## 图片下间隙

```plain
img{
   vertical-align: middle;
}
```

## 移动端touch

```plain
1. touch是移动端的触摸事件 而且是一组事件
2. touchstart   当手指触摸屏幕的时候触发
3. touchmove    当手指在屏幕来回的滑动时候触发
4. touchend     当手指离开屏幕的时候触发
5. touchcancel  当被迫终止滑动的时候触发（来电，弹消息）
6. 利用touch相关事件实现移动端常见滑动效果和移动端常见的手势事件
使用touch:
1.绑定事件：box.addEventListener('touchstart',function (e) { });
2.事件对象：
名字：TouchList------触摸点（一个手指触摸就是一个触发点，和屏幕的接触点的个数）的集合
changedTouches    改变后的触摸点集合
targetTouches     当前元素的触发点集合
touches           页面上所有触发点集合
3.触摸点集合在每个事件触发的时候会不会去记录触摸
changedTouches 每个事件都会记录
targetTouches，touches 在离开屏幕的时候无法记录触摸点
4.分析滑动实现的原理：
4.1 就是让触摸的元素随着手指的滑动做位置的改变
4.2 位置的改变：需要当前手指的坐标
4.3 在每一个触摸点中会记录当前触摸点的坐标 e.touches[0] 可以拿到第一个手指触摸点
4.4 clientX clientY      基于浏览器窗口（视口）
4.4 pageX   pageY        基于页面（视口）
4.4 screenX screenY      基于屏幕
```

## 定时器interval

如果是遇到可能有负数的情况，先--，然后在判断是否需要移除

```plain
 const timer = setInterval(() => {
        this.countdowmTime --   // 先减后判断是否移除
        if(this.countdowmTime <= 0){
          clearInterval(timer)
        }
}, 1000);
```

## 三目运算符

	条件是否成立，条件成立为结果1，否则为结果2

```plain
int a = 1, b = 2, z;
z = a > b ? a : b;  //去了括号
console.log(z) // 2
```

## 数组拼接

```plain
使用concat拼接(括号里是新的内容)
this.comments = this.comments.concat(res.data.message)
使用扩展运算符拼接(前面的是原数组，后面的是新的内容)
this.goodsList:[...this.goodsList,...res.goods]
使用push和扩展运算符
this.goodList.push(...res.goods)
```

使用第一种的

```plain
if (res.data.status == 0) {
    //拼接评论数据，而不是覆盖评论数组
    res.data.message.length ? res.data.message : Toast("没有更多数据")
    this.comments = this.comments.concat(res.data.message)
    console.log(res.data.message)
}
```

## 图片上传



## 自动聚焦

```plain
@opened="$refs.name.focus()"
触发事件="$refs.xxx.focus()"
```

## 单向绑定vs双向绑定

```javascript
单向数据绑定
<input :value="user.name" @input="inputName = $event"/> 
:value="data中的数据"
$event 标识事件参数，是Vue提供的，可以直接获取到input的值
@input="inputName = $event"
事件中更新
this.user.name = this.inputName
双向数据绑定
v-model="data中的数据"
```


## 含变量的请求方法

[变量]:value

```plain
async saveProfile (field, value) {
  this.$toast.loading({
    duration: 0, // 持续时间，0表示持续展示不停止
    forbidClick: true, // 是否禁止背景点击
    message: '保存中...' // 提示消息
  })
  try {
    await updateUserProfile({
      [field]: value
    })
    this.$toast.success('保存成功')
    this.user[field] = value
    globalBus.$emit('user-update')
    this.isEditGenerShow = false
  } catch (err) {
    this.$toast.success('保存失败')
    return Promise.reject(err)
  }
},
```

## 不调整css直接触发隐藏元素点击事件

```plain
<input type="file" hidden accept="image/*" ref="file" />
<button @click="uploadFile">上传</button>
uploadFile(){
  this.$refs.file.click()
}
```

## better-scroll不能与sticky共存

## 获取组件的元素

```plain
console.log(this.$refs.tabcontrol.$el)
```

## 监听组件的点击

```
<BackTop @click.native="backClick" v-show="scrollY > 1000" />
```

## 复杂的数据中取数据

```plain
在index.js中
export class Goods {
	  constructor(itemInfo, columns, services) {
	    this.title = itemInfo.title;
	    this.columns = columns;
	    this.services = services;
	  }
}
请求数据
import {Goods} from './api'
this.goods = new Goods(data.itemInfo, data.columns, data.shopInfo.services);
```

## 判断数组对象是否为空

```plain
数组
arr.length > 0
对象
Object.keys(goods).length !== 0
```

## 直接使用数组的最后一个

```plain
{{goods.services[goods.services.length-1].name}}
```


## 使用数组的其中几个值

```plain
遍历除数组最后一个值
v-for"item in 10" item => 1,2...10
<div class="info-service">
<span class="info-service-item" v-for="index in goods.services.length-1" :key="index">
<img :src="goods.services[index-1].icon">
<span>{{goods.services[index-1].name}}</span>
</span>
</div>
```





## 城市列表的数据



## 接口可传可不传的params

如果用户传了就使用params对象，如果用户没有传就使用{}

```plain
export default reqdata(params = {}){
  url: '...',
  params
}
```

## 并发进行的请求

```plain
import {getArtical} from '@/api/article'
import {getTags} from '@/api/tag'
并发进行
const [res1,res2] = await Promise.all([getArtical(),getNews()])

分开请求
const {data} = await getArtical()
const {data: tagData} = await getNews()
```


## 判断添加到数组中的内容是否重复





## 共用同一个方法



```js
handleClick(type){
    // 默认选中城市列表第一个
    // if(this.cities.length > 0){
    //     if(type === "depart"){
    //         this.form.departCity = this.cities[0].value;
    //         this.form.departCode = this.cities[0].sort;
    //     }
    //     if(type === "dest"){
    //         this.form.destCity = this.cities[0].value;
    //         this.form.destCode = this.cities[0].sort;
    //     }
    // }  
    // 另一种写法
    if(this.cities.length === 0) return;
    this.form[type + "City"] = this.cities[0].value;
    this.form[type + "Code"] = this.cities[0].sort;
        },
```



## 历史记录

### tia保存到localstorage

点击查询按钮的时候，发送请求查询结果，同时将本次查询需要显示的参数存放到一个数组中

```js
<el-button style="width:100%;"  type="primary"  icon="el-icon-search" @click="handleSubmit">
    搜索
</el-button>

handleSubmit(){
    const historyList = JSON.parse(localStorage.getItem('history') || '[]')
    historyList.unshift('需要存储的参数')
    localStorage.setItem('history',JSON.stringify(historyList))
}
```



### 保存到vuex

组件中

```js
<el-button style="width:100%;"  type="primary"  icon="el-icon-search" @click="handleSubmit">
    搜索
</el-button>
// 保存到store
this.$store.commit("air/setHistory", this.form);
```

vuex文件夹下的文件

```js
export const state = () => {
    return {
        // 搜索的历史记录
        history: []
    }
}

export const mutations = {
    // 设置history的值,data是搜索表单的对象
    setHistory(state, data){
        // 把最新的记录追加到第一个
        state.history.unshift(data);
    }
}
```

## 前端生成二维码

https://github.com/soldair/node-qrcode

https://github.com/soldair/node-qrcode/tree/master/examples

下载

```js
npm install --save qrcode
```

引入

```js
import QRCode from 'qrcode'
```

使用

```vue
<template>
<div class="qrcode">
    <!-- 二维码 -->
    <canvas id="qrcode-stage"></canvas>

    <p>请使用微信扫一扫</p>
    <p>扫描二维码支付</p>
</div>
</template>
<script>
export default{
    methods:{
        getInfo(){
            // 请求完成数据获取到订单号后
            // 获取canvas元素
            const canvas = document.querySelector("#qrcode-stage");
            QRCode.toCanvas(canvas, 需要转化的URL, {
                width: 200
            });
        }
    }
}
</script>
```



## 下载excel二进制数据流返回原页面

```js
exportUser: function (callback) {
     let url=`下载的地址路径`
     window.open(url)
     callback();
 },
     
==========使用=============
this.$api.exportUser(() => {this.$message.success('导出成功')});
```





## 封装 better-scroll 的使用

**轮播图横向滑动要先给ul加width，同时要开启scrollX： true**

better-scroll 的模板

```vue
<template>
  <div class="wrapper" ref="wrapper">
    <div class="content">
      <slot></slot>
    </div>
  </div>
</template>
<script>
import BScroll from "better-scroll";
export default {
  data() {
    return {
      scroll: null
    };
  },
  props: {
    probeType: {
      type: Number,
      default: 0
    },
    pullUpLoad: {
      type: Boolean,
      default: false
    },
    pullDownRefresh: {
      type: Boolean,
      default: false
    },
    scrollX:{
      type: Boolean,
      default: false
    }
  },
  methods: {
    _initScroll() {
      if (!this.scroll) {
        this.scroll = new BScroll(this.$refs.wrapper, {
          scrollX: this.scrollX
          click: true,
          mouseWheel: true,
          probeType: this.probeType,
          pullUpLoad: this.pullUpLoad,
          pullDownRefresh: this.pullDownRefresh
        });

        if (this.probeType !== 0) {
          // 监测滚动位置
          this.scroll.on("scroll", position => {
            this.$emit("scrollPosition", position);
          });

          // 监测滚动条最末端的位置
          this.scroll.on("scrollEnd", position => {
            this.$emit("scrollEndPosition", position);
          });
        }

        if (this.pullUpLoad) {
          this.scroll.on("pullingUp", () => {
            this.scroll.finishPullUp()
            this.$emit("pullingUp");
          });
        },

        if (this.pullDownRefresh) {
          this.scroll.on("pullingDown", () => {
            this.$emit("pullingDown");
          });
        },
      }
    },

    // 到达指定的位置
    scrollTo(x, y, time = 300) {
      this.scroll && this.scroll.scrollTo(x, y, time);
    },

    // 到达指定的元素
    scrollToElement(el,time = 300) {
      this.scroll && this.scroll.scrollToElement(el, time);
    },

    // 刷新
    refresh() {
      this.scroll && this.scroll.refresh();
    },

    // 重复加载
    finishPullUp() {
      this.scroll && this.scroll.finishPullUp();
    }
  },
  mounted() {
    this.$nextTick(() => {
      this._initScroll()
    })
  }
};
</script>
```

组件中使用

> 引入注册组件，给 scroll 设置需要滚动的范围
>
> 将需要滚动的内容放到`scroll`中包裹起来
>
> 如果要开启横向滚动，父组件传值给子组件`:probeType="3"`
>
> 如果要监听滚动距离，父组件传值给子组件`:scrollX="true"`
>
> 如果要上拉加载，父组件传值给子组件`:pullUpLoad="true"`并监测滚动位置事件`@scrollPosition="scrollPosition"`和上拉加载事件`@pullingUp="loadMore"`
>
> 如果下拉刷新，父组件传值给子组件`:pullDownRefresh="true"`并监听下拉刷新事件`@pullingDown="pullingDown"`
>
> 如果直接达到某一个地方，父组件调用子组件方法`this.$refs.scroll.scrollTo(0, this.scrollY, 0)`,点击达到指定位置或进入当前页面回到对应的位置
>
> 如果到达指定的元素位置，父组件调用子组件方法`this.$refs.scroll.scrollToElement(li, 500)`,
>
> 如果重置滚动条高度，父组件调用子组件方法`this.$refs.scroll && this.$refs.scroll.refresh()`,一般用于 mounted 挂载时重置，或等图片加载完成后重置

```vue
<template>
  <scroll class="homeScroll" ref="homeScroll" :probeType="3" :pullUpLoad="true" @scrollPosition="scrollPosition" @pullingUp="loadMore">
    <!-- 轮播图 -->
    <home-swipe :banner="banner" class="home_swiper"></home-swipe>
    <!-- 推荐列表 -->
    <home-recommend :recommend="recommend"></home-recommend>
  </scroll>
</template>

<script>
methods:{
    scrollPosition(position) {
      this.scrollY = Math.abs(position.y);
    },

    loadMore() {
      this.getGoodsList(this.currentType);
    },

    // 请求的下拉页面事件
    async getGoodsList(type) {
      // 在不同的类型上页码值随着滑动而增加
      const page = this.goods[type].page + 1;
      const res = await reqHomeGoodsList(type, page);

      if (res.success) {
        this.goods[type].list.push(...res.data.list);
        this.goods[type].page += 1;
      }
    }
}
</script>

<style scoped lang="less">
.homeScroll {
  height: calc(100% - 93px); /*calc两边需要有空格，否则实现不了*/
  overflow: hidden;
}
</style>
```

### 图片导致的滚动 bug

**请求的数据中图片没加载完成不能形成滚动**

解决办法：监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次 refresh()

**监听图片加载完成**

```html
原生的js监听图片: img.onload = function() {}
<img onload="function()" {} />
Vue中监听: @load='方法'
<img @load="loadImg" />

<img :src="goodItem.img" v-if="goodItem.img" @load="imageLoad" />

监听加载完成后刷新滚动条的高度 loadImg: debounce(function(){{ this.$refs.rightScroll && this.$refs.rightScroll.refresh() },
```

### 获取 offsetTop 不正确的 bug

原因：图片没有加载完成就获取 offsetTop，导致不正确

解决办法：待图片加载完成再获取

```html
<img :src="goodItem.img" v-if="goodItem.img" @load="imageLoad" />

监听加载完成后刷新滚动条的高度 loadImg: debounce(function(){{ this.tabHeight = this.$refs.tabcontrol.$el.offsetTop },
```

### 导航条吸顶

导航条滚动到一定距离之后吸顶,在 scroll 滚动外侧放置一个隐藏的 tab 栏，到达指定位置后 tab 栏显示，原来的 tab 栏隐藏

```vue
<template>
  <!-- 到达指定位置出现的tab栏 -->
  <tab-control v-show="isShowTab"></tab-control>

  <scroll>
    <!-- 轮播图 -->
    <home-swipe></home-swipe>

    <div>
      <!-- tab栏 -->
      <tab-control v-show="!isShowTab"></tab-control>
    </div>
  </scroll>
</template>
<script>
computed:{
    isShowTab() {
      if (this.scrollY > this.tabHeight) {
        return true;
      } else {
        return false;
      }
    },
}
</script>
```

## 上拉刷新下拉加载

### 上拉加载

滚动条触底 开始加载下一页数据

1. 找到滚动条触底事件

2. 判断还有没有下一页数据

3. 获取到总页数 计算总条数

    总页数 = Math.ceil(总条数 / 页容量 pagesize)【总页数 = Math.ceil( 23 / 10 ) = 3】

4. 获取到当前的页码 pagenum

    判断一下 当前的页码是否大于等于 总页数 【if(totalPage>=this.pagenum)】

    表示 没有下一页数据

5. 假如没有下一页数据 弹出一个提示

6. 假如还有下一页数据 来加载下一页数据
   1 当前的页码 ++

    2 重新发送请求 this.getGoodsList()

    3 数据请求回来 要对 data 中的数组 进行 拼接 而不是全部替换！！！

    【goodsList:[...this.data.goodsList,...res.goods] 或 this.list.**push**(...res.data.list)】

### 下拉刷新页面

1. 触发下拉刷新事件
2. 重置 数据 数组 【goodsList: []】
3. 重置页码 设置为 1
4. 重新发送请求 this.getGoodsList()
5. 数据请求回来 需要手动的关闭 等待效果【在请求成功的函数写关闭代码】

## 加入购物车

1. 先绑定点击事件
2. 获取 缓存/vuex 中的购物车数据 数组格式
3. 先判断【findIndex】当前的商品是否已经存在于 购物车
4. 已经存在 修改商品数据 执行购物车数量++ 重新把购物车数组 填充回缓存中
5. 不存在于购物车的数组中 直接给购物车数组添加一个新元素 push 新元素 带上 购买数量属性 num 重新把购物车数组 填充回缓存中
6. 弹出提示添加到购物车成功

### js 的方法

```js
handleCartAdd() {
  // 1 获取缓存中的购物车 数组
  let cart = JSON.parse(localStorage.getItem('cart') || '[]')
  // 2 判断 商品对象是否存在于购物车数组中
  let index = cart.findIndex(v => v.goods_id === this.GoodsInfo.goods_id);
  if (index === -1) {
    //3  不存在 第一次添加
    this.GoodsInfo.num = 1;
    this.GoodsInfo.checked = true;
    this.cartList.push(this.GoodsInfo);
  } else {
    // 4 已经存在购物车数据 执行 num++
    this.cartList[index].num++;
  }
  // 5 把购物车重新添加回缓存中
  localStorage.setItem("cart", JSON.stringify(cart));
},
```

### vuex 的方法 1

```js
actions: {
 addToCart({commit, state}, good){
    const index = state.cartList.findIndex(item => item.iid === good.iid)
    if(index === -1){
      commit(ADD_CART, good)
    }else{
      commit(ADD_COUNT, index)
    }
  },
}
mutations: {
  [ADD_CART](state, good){
    Vue.set(good, "count", 1)
    state.cartList.push(good)
  },

  [ADD_COUNT](state, index){
    state.cartList[index].count ++
  },
}
```

### vuex 的方法 2

```js
actions: {
 addToCart({commit, state}, good){
  let oldProduct = null
  state.cartList.some(item => {
    if(item.iid === good.iid){
      oldProduct = item
    }
  })
  if(oldProduct){
    commit(ADD_COUNT, good)
  }else{
    commit(ADD_CART, good)
  }
}
mutations: {
  [ADD_CART](state, good){
    Vue.set(good, "count", 1)
    state.cartList.push(good)
  },

  [ADD_COUNT](state, good){
    good.count ++
  },
}
```

## 商品收藏

页面`created`时，读取缓存中的商品收藏的数据

1. 判断当前商品是不是被收藏
2. 是 ------------> 改变页面的图标
3. 不是
   1. 点击商品收藏按钮
   2. 判断该商品是否存在于缓存数组中 【some】 请求完成才可以判断是否有该商品
   3. 已经存在 把该商品删除 【splice】
   4. 没有存在 把商品添加到收藏数组中 存入到缓存中即可 【push】

### 方式一

优点：不需要单独用一个数组来保存是否被收藏

在获取到商品列表数据后，给每个商品添加一个标识`isCollect:false`后再将内容保存会 data 中，通过读取数据来确定是否有收藏商品；

如果有收藏`:class="{active : item.isCollect}"`

### 方式二

获取当前商品的 id，默认是给商品加收藏

```js
<div @click="handelCollect">收藏</div>

data: {
  // 当前商品是否被收藏
  isCollect:false,
  collectList:[]
},
mounted(){
  async getGoodsDetail(){
    const result = await request({url: '/goods/detail', data:this.queryInfo})
    this.goodsObj = result

    // 加载缓存中的商品收藏的数据
    this.collectList = JSON.parse(localStorage.getItem("collectList") || '[]')
    // 判断缓存中是否有该商品
    this.isCollect = collectList.some(item => item.goods_id === this.goodsObj.goods_id)
   },
}

methods:{
  // 商品收藏
  handelCollect(){
    // 1 判断该商品是否存在于缓存数组中
    const index = this.collectList.findIndex(item => item.goods_id === this.goodsObj.goods_id)

    // 2 已经存在 把该商品删除
    if(index !== -1){
      <i class="ion-close-round" @click="deleteTag(index)"></i>
      this.isCollect = false
    }else{
      // 3 没有存在 把商品添加到收藏数组中 存入到缓存中即可
      this.collectList.push(this.goodsObj)
      this.isCollect = true
    }

    // 4. 将值存入缓存中
    localStorage.setItem("collectList", JSON.stringify(this.collectList))
  }
}
```

## 商品支付

支付按钮

先获取 token 然后，判断缓存中有没有 token

没 token 跳转到登录页面登录

有 token

1. 准备发送请求 创建订单 获取订单编号
2. 发起 预支付接口
3. 发起微信支付 wx-requestPayment
4. 查询后台 订单状态 分别提示支付成功和支付失败
5. **手动删除缓存中 已经被选中了的商品**
   let newCart=wx.getStorageSync("cart")
   newCart=newCart.filter(v=>!v.checked) // 过滤只剩下没有被选中的商品
6. 删除后的购物车数据 填充回缓存
   wx.setStorageSync("cart", newCart)
7. 再跳转页面

## 多层嵌套评论

comment_id 为当前的评论评级

如果 parent_id 有值则为回复的评论

https://www.bilibili.com/video/BV1vT4y137So?p=33

```json
[
  { "comment_id": 1, "user_id": 43, "comment_date": "04-23", "comment_content": "蜡笔小新很好看!", "parent_id": null },
  { "comment_id": 2, "user_id": 19, "comment_date": "04-24", "comment_content": "还不错哦!很好看", "parent_id": null },
  { "comment_id": 3, "user_id": 17, "comment_date": "04-25", "comment_content": "我也感觉蜡笔小新很好看", "parent_id": "1" },
  { "comment_id": 4, "user_id": 14, "comment_date": "04-26", "comment_content": "我感觉机器猫更好看一点", "parent_id": "3" },
  { "comment_id": 5, "user_id": 13, "comment_date": "04-27", "comment_content": "好看,已三连!", "parent_id": null },
  { "comment_id": 6, "user_id": 21, "comment_date": "04-26", "comment_content": "你是机器猫的粉丝吗", "parent_id": "4" },
  { "comment_id": 7, "user_id": 14, "comment_date": "04-27", "comment_content": "是的,我是机器猫的粉丝", "parent_id": "6" },
  { "comment_id": 8, "user_id": 23, "comment_date": "04-27", "comment_content": "我更喜欢白嫖!", "parent_id": "5" },
  { "comment_id": 9, "user_id": 25, "comment_date": "04-28", "comment_content": "你个白嫖怪", "parent_id": "8" }
]
```

## 歌词解析

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      p.active {
        color: red;
      }
    </style>
  </head>
  <!-- https://www.bilibili.com/video/BV1ye411p7w3?p=48 -->
  <body>
    <div id="app">
      <audio src="./mp3/2.mp3" controls ref="audio"></audio>
      <div v-for="(value, key, index) in lrcObj" :key="key" style="text-align: center;">
        <!-- 显示时：currentTime 大于当前的key， 小于下一个key ==> 设计一个key数组 -->
        <p :class="currentTime >= currentKeys[index] &&  currentTime < currentKeys[index + 1] ? 'active' : ''">{{value}}</p>
      </div>
    </div>
    <script src="./js/vue.js"></script>
    <script>
      new Vue({
        el: '#app',
        data: {
          lrc: {
            version: 1,
            lyric:
              '[by:葫芦-小-金刚]\n[00:00.000] 作曲 : 郑秋枫\n[00:01.000] 作词 : 瞿琮\n[00:07.754] 百灵鸟从蓝天飞过\n[00:25.848] 我爱你中国\n[00:44.110]\n[01:09.562] 我爱你中国\n[01:16.698] 我爱你中国\n[01:23.330] 我爱你春天蓬勃的秧苗\n[01:29.878] 我爱你秋日金黄的硕果\n[01:36.927] 我爱你青松气质\n[01:43.418] 我爱你红梅品格\n[01:50.103] 我爱你家乡的甜蔗\n[01:54.920] 好像乳汁滋润着我的心窝\n[02:04.858] 我爱你中国\n[02:12.027] 我爱你中国\n[02:19.002] 我要把最美的歌儿献给你\n[02:25.517] 我的母亲我的祖国\n[02:34.071]\n[02:46.141] 我爱你中国\n[02:52.828] 我爱你中国\n[02:59.436] 我爱你碧波滚滚的南海\n[03:05.749] 我爱你白雪飘飘的北国\n[03:13.225] 我爱你森林无边\n[03:19.760] 我爱你群山巍峨\n[03:26.110] 我爱你淙淙的小河\n[03:31.159] 荡着清波从我的梦中流过\n[03:41.374] 我爱你中国\n[03:48.376] 我爱你中国\n[03:55.123] 我要把美好的青春献给你\n[04:01.591] 我的母亲我的祖国\n[04:09.380] 啊~~~\n[04:22.596] 我要把美好的青春献给你\n[04:29.422] 我的母亲我的祖国\n',
          },
          lrcObj: {},
          currentTime: 0, // 当前播放的时间
          duration: 0, // 总时长
          currentKeys: [],
        },
        mounted() {
          this.formateLrc()
        },
        methods: {
          // 将歌词格式化为数组对象[{1:"jfkd"},{34:"jfklds"}]
          formateLrc() {
            // 去除所有的空格,"[00:12.570]难以忘记初次见你"
            const arr = this.lrc.lyric.split('\n')
            // 分开数字和歌词的正则表达
            const reg = /\[\d*:\d*(\.|:)\d*]/g
            let obj = {}
            for (let i = 0; i < arr.length; i++) {
              // 歌词时间
              const time = arr[i].match(reg)
              // 歌词文本
              const text = arr[i].replace(time, '')

              // 含有所有时间的字符串
              if (time) {
                // 将时分秒转成数字格式
                const min = Number(time[0].match(/\[\d*/i).toString().slice(1)) //"[00" => 00
                const second = Number(time[0].match(/:\d*/i).toString().slice(1)) //":34" =>34
                const currentTime = min * 60 + second
                obj[currentTime] = text
                this.currentKeys.push(currentTime)
              }
            }
            this.lrcObj = obj

            this.$nextTick(() => {
              this.addEventAudio()
            })
          },

          // 监听播放器的事件
          addEventAudio() {
            // 1. 歌曲当前播放的时间
            this.$refs.audio.addEventListener('timeupdate', () => {
              this.currentTime = this.$refs.audio.currentTime
            })
            // 2. 歌曲的总时长
            this.$refs.audio.addEventListener('canplay', () => {
              this.duration = this.$refs.audio.duration
            })
          },
        },
      })
    </script>
  </body>
</html>
```

## 城市列表

```html
<!DOCTYPE html>
<html lang="en">
  <!-- https://www.bilibili.com/video/BV1KE411s7kX?p=100 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <div v-for="item in cities" :key="item.cityId">
        <p style="background-color: aquamarine;">{{item.letter}}</p>
        <p v-for="(city, index) in item.list" :key="index">{{city.name}}</p>
      </div>
    </div>
    <script src="./js/vue.js"></script>
    <script>
      var vm = new Vue({
        el: '#app',
        data: {
          cityData: [
            {
              cityId: 110100,
              name: '北京',
              pinyin: 'beijing',
              isHot: 1,
            },
            {
              cityId: 650500,
              name: '哈密',
              pinyin: 'hami',
              isHot: 0,
            },
            {
              cityId: 320200,
              name: '无锡',
              pinyin: 'wuxi',
              isHot: 0,
            },
          ],
          cities: [],
        },
        created() {
          this.formatCity()
        },
        methods: {
          formatCity() {
            let letterArr = []
            // 选出26个字母
            for (let i = 65; i < 91; i++) {
              letterArr.push(String.fromCharCode(i))
            }
            let newCityList = []
            // 从数组中取出数据进行对比
            for (let j = 0; j < letterArr.length; j++) {
              // 过滤字母相同的数组
              const tempArr = this.cityData.filter((item) => item.pinyin.slice(0, 1) === letterArr[j].toLowerCase())
              if (tempArr.length > 0) {
                newCityList.push({
                  letter: letterArr[j],
                  list: tempArr,
                })
              }
            }
            this.cities = newCityList
          },
        },
      })
    </script>
  </body>
</html>
```

## 手机端城市列表

点击某个字母跳转到对应的位置(使用 better-scroll 中的 scrollToElement)

[参考](<[vue项目,Vue旅游网项目_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ik4y1174T?p=25)>)

## 支付页面

![1592361887347](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592361887347.png)

- 发送请求获取订单的相关数据

```js
// 请求订单详情
const res = await this.$axios({
  url: '/airorders/' + id,
  headers: {
    Authorization: `Bearer ${this.$store.state.user.userInfo.token}`,
  },
})
this.order = res.data
```

- 是否需要形成二维码,若形成则添加

```js
// 获取canvas元素
const canvas = document.querySelector('#qrcode-stage')
QRCode.toCanvas(canvas, this.order.payInfo.code_url, {
  width: 200,
})
```

- 轮询【定时器】查接口看是否已支付，如果已经支付则取消轮询【清除定时器】，如果没有支付继续轮询

```js
// 查询付款状态
this.timer = setInterval(async () => {
  const res = await this.$axios({
    url: '/checkpay',
    method: 'POST',
    headers: {
      Authorization: `Bearer ${this.$store.state.user.userInfo.token}`,
    },
    data: {
      id: this.$route.query.id,
    },
  })
  // 获取支付状态
  const { statusTxt } = res.data
  // 支付完成之后判断
  if (statusTxt === '支付完成') {
    this.$message.success(statusTxt)
    clearInterval(this.timer)
  }
}, 3000)
```

- 如果不支付直接跳转到其他页面，需要跳转前询问，若离开则销毁当前的组件`destroyed`

```js
 // 组件销毁时候使用的，一般情况下用于清除定时器
destroyed(){
    clearInterval(this.timer);
}
```

## base64 加密

安装

```
npm install --save js-base64
```

直接使用

```js
import { Base64 } from 'js-base64'
let latin = 'dankogai'
Base64.encode(latin)
```

封装再使用

```js
processPassword(pw){
      let Base64 = require('js-base64').Base64;
      var str = Base64.encode(pw);
      if(str.length>2){
        var lp = str.substr(0,2);
        var rp = str.substr(2,str.length);
        pw = rp+lp;
      }
      return pw;
    },

 login(){
 	let password
 	password=this.processPassword(this.password);
 }
```

## codemirror 编辑器

![Snipaste_2020-10-07_12-56-57.png](https://pic.gksec.com/2020/10/07/30a20b27622ac/snipaste_2020-10-07_12-56-57.png)

实现功能：

上一步

下一步

字体大小刷新

编辑器高度

```
<template>
  <div :style="wrapStyle">
    <textarea ref="mycode" v-model="code"></textarea>
  </div>
</template>

<script>
// 核心样式
import "codemirror/lib/codemirror.css";
// 引入主题后还需要在 options 中指定主题才会生效

// 需要引入具体的语法高亮库才会有对应的语法高亮效果
import "codemirror/mode/javascript/javascript.js";

// require active-line.js
import "codemirror/addon/selection/active-line.js";

let CodeMirror = require("codemirror/lib/codemirror");

export default {
  name: "codeMirror",
  data() {
    return {
      editor: null,
      options: {
        mode: "javascript",
        tabSize: 0, // 缩进格式
        lineNumbers: true, // 显示行号
        autofocus: true, //初始化时自动获取焦点
        autoRefresh: true,
      },
    };
  },
  methods: {
    // 获取编辑器的值
    getEditor() {
      return this.editor.doc.getValue();
    },
    // 传值进来设置
    setCodeEditor(val) {
      this.editor.doc.setValue(val);
    },
    undo() {
      // 判断是否与原来的代码一致，一致就操作
      let chartCode = this.code;
      if (chartCode !== this.getEditor()) {
        this.editor.doc.undo();
      }
    },
    redo() {
      this.editor.doc.redo();
    },

    _initEditor() {
      if (!this.editor) {
        this.editor = CodeMirror.fromTextArea(this.$refs.mycode, this.options);
      }
      this.editor.setValue(this.value || this.code);
      this.editor.setSize("auto", this.editorHeight);
    },
  },
  mounted() {
    this.$nextTick(() => {
      this._initEditor();
    });
  },
  watch: {
    code() {
      this.$nextTick(() => {
        this._initEditor();
      });
    },
    wrapStyle() {
      setTimeout(() => {
        this.refresh();
      }, 100);
    },
  },
  computed: {
    wrapStyle() {
      return { fontSize: this.fontSize + "px" };
    },
  },
  props: {
    fontSize: {
      type: String,
    },
    // 内部真实的内容
    code: {
      type: String,
      default: "",
    },
    // 脚本编辑器高度
    editorHeight: {
      type: String,
      default: "600px",
    },
  },
};
</script>

```



## 右键新建菜单

![image.png](https://pic.gksec.com/2020/10/09/0609b64e8e395/image.png)

功能：

没有打开显示完成文件夹图标

打开后显示打开的文件夹图标，子项用文档图标显示

点击右键新建

点击左键取消右键的新建模块

```vue
<template>
  <el-scrollbar class="height100 br-2" :native="false">
    <el-tree :props="props" lazy :load="loadNode" :expand-on-click-node="false" @node-click="onClickNode" class="relative">
      <span class="smallfont custom-tree-node" slot-scope="{ node, data }" @contextmenu.prevent.stop="showCreat($event, data.id)">
        <span><i :class="getTreeImg(node)" style="color:#409EFF;padding-right:5px;"></i>{{ data.name }}</span>
        <span @click="delectModules(data.id)"><i class="delModule el-icon-delete d-none" style="color:#409EFF;padding-right:5px;"></i></span>
      </span>
    </el-tree>
    <div v-if="mouseCreatVisible" :style="mouseCreatStyle">
      <el-button size="mini" @click="mouseCreat">新建</el-button>
    </div>
  </el-scrollbar>
</template>

<script>
export default {
  data() {
    return {
      activeName: 'basicInfor',
      active: 'basicInfor',
      props: {
        label: 'name',
        children: 'zones',
        isLeaf: 'hasChild',
      },
      node: [],
      resolve: function () {},
      visible: false,
      dialogVisible: false,
      params: {
        appId: '',
        id: '',
        name: '',
        description: '',
        superior: '',
        superiorName: '',
        orderNo: 0,
      },
      data: [],
      mouseCreatVisible: false, //右键新建的显示标识
      mouseCreatStyle: '', //右键新建的样式
    }
  },

  methods: {
    /**
     * 加载树下级
     */
    loadNode(node, resolve) {
      let appId = sessionStorage.getItem('appId')
      let parentId = node.data != undefined ? node.data.id : ''
      let data = []
      if (node.level === 0) {
        this.node = node
        this.resolve = resolve
        getModulesTree(appId, parentId, {
          onSucess: (response) => {
            if (response.data.errcode == 0) {
              data = response.data.data
              if (node.data != undefined) {
                return resolve([{ name: node.data.name }])
              }
              return resolve(data)
            }
          },
        })
      }
      if (node.level >= 1) {
        getModulesTree(appId, parentId, {
          onSucess: (response) => {
            if (response.data.errcode == 0) {
              data = response.data.data
              if (node.data != undefined) {
                return resolve(data)
              }
            }
          },
        })
      }
    },
    /**
     * 点击模块树节点
     * 传递给 data 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身
     */
    onClickNode(data) {
      this.$store.dispatch('rightHelpPageParams', { title: '模块信息', url: 'application/application_module_form_list_help.html' })
      console.log(data)
      let appId = sessionStorage.getItem('appId')
      this.visible = true
      this.active = 'basicInfor'
      let params = {
        appId: appId,
        moduleId: data.id,
      }
      this.$router.push({ path: '/home/softwaresdetails/basicinfor', query: { edit: true, params: params } })
    },

    showCreat(event, id) {
      this.params.superior = id
      this.mouseCreatStyle = `position:absolute;top:${event.target.offsetTop + 15}px;left:${event.x - 10}px;`
      this.mouseCreatVisible = true
    },
    mouseCreat() {
      this.mouseCreatVisible = false
      this.dialogVisible = true
    },
    getTreeImg(node) {
      let className = ''
      if (node.isLeaf) {
        className = 'el-icon-document'
      } else if (!node.expanded) {
        className = 'el-icon-folder'
      } else {
        className = 'el-icon-folder-opened'
      }
      return className
    },
  },
}
</script>
<style>
.relative {
  position: relative;
}
</style>
```



## 鼠标悬浮时显示新建

vue 中没有 hover，可以使用 css 伪类**：hover** 或者**@mouseenter @mouseleave @mouseover @mouseout** 等处理类似需求

## vue 嵌套的 iframe 控制全屏和非全屏

![image.png](https://pic.gksec.com/2020/10/10/a3b541225507f/image.png)

iframe

```html
<html>
  <button class="handleTest btn" onclick="handleTest(this)">全屏操作</button>
  <button class="closeAllScren btn" onclick="closeAllScren(this)" style="display:none">取消全屏</button>
  <script>
    function handleTest(event) {
      window.parent['handleSpanClick'](true)
      document.getElementsByClassName('handleTest')[0].setAttribute('style', 'display:none')
      document.getElementsByClassName('closeAllScren')[0].setAttribute('style', 'display:inline-block')
    }
    function closeAllScren(event) {
      window.parent['handleSpanClick'](false)
      document.getElementsByClassName('handleTest')[0].setAttribute('style', 'display:inline-block')
      document.getElementsByClassName('closeAllScren')[0].setAttribute('style', 'display:none')
    }
  </script>
</html>
```

vue

```vue
<template>
  <div v-show="activeName == 'content'">
    <iframe ref="formFormat" :src="src" width="100%" :height="iframeHeight" frameborder="0" :style="iframeStyle"></iframe>
  </div>
</template>

<script>
export default{
    data:{
     return {
        spanClick: 'handleSpanClick',
        iframeStyle:'',//iframe全屏样式
      	iframeHeightBefore:100,
     }
    }
	mounted(){
        /**
         * 动态计算页面table高度
         */
        getScollerHeight() {
          setTimeout(() => {
            let clientHeight = document.documentElement.clientHeight || document.body.clientHeight;
            //60 头部， 32 面包屑， 41 第一层页签， 40 第二层页签， 50 列表标题， 71 查询， 20 父组件外边距, 40分页, 16 外边距
            //这个组件在父组件dialog中高度给的85%，54 弹窗标题 30 弹窗底部padding 50 第一季页签 20机动距离
            this.tableHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 16;
            this.operaHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 48; //48操作列操作栏
            this.iframeHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 16;
            this.iframeHeightBefore = clientHeight - 60 - 32 - 41  + "px";
          }, 100);
        }

		if (this.$route.query.params.showType == "pc")
		this.src = `./formHtml/fcktest2.html?contextPath=${getContextPath()}`
    	else
    	this.src = `./formHtml/formbuilder/index.html?contextPath=${getContextPath()}`
	},
	created(){
        //操作iframe的全屏事件
        window[this.spanClick]=(isScresn)=>{
          this.allScrean(isScresn);
        }
  	},
  	methods:{
  		allScrean(isScresn){
          if(isScresn ){
            this.iframeStyle='position:absolute;top:0;left:0;right:0;bottom:0;z-index:10';
            this.iframeHeight='100%';
          }else{
            this.iframeStyle='';
            this.iframeHeight=this.iframeHeightBefore;
          }
        },
  	}
}
</script>
```



## 取多层结3构的对象报错

**取一个对象三层及三层以上的内容**会报错，可以通过 v-if 来解决

如果在 undefined 中读取不到 length，尝试通过 children 的方式来获取，证明mounted中加载 better-scroll 的时间早了，可以增加判断条件来确定什么时候初始化better-scroll；



## 过滤评论内容

子组件想要改变父组件的状态内容，用子组件向父组件传值

过滤判断条件：先确定【全部 / 推荐 / 吐槽】，再确定【是否只看有评论的内容】

```plain
filterRatingsComment(){
      /**
       * 情况1： 
       * data的activeType： 0 / 1 / 2
       * ratings的rateType： 0 / 1
       * => activeType === 2 || activeType ===  rateType
       * 
       * 
       * 情况2
       * data的onlyText： true / false
       * ratings的text: 有 / 无
       * => !onlyText || onlyText && text.length > 0
       * 
       */
      const {onlyText, activeType, ratings} = this
      return ratings.filter((item) => {
        return (activeType === 2 || activeType ===  item.rateType) && (!onlyText || onlyText && item.text.length > 0)
      })
    }
```



## 伪数组转真数组遍历

伪数组如果想要实现forEach方法，可以通过改变this指向

```plain
模板：
Array.prototype.forEach.call(需要遍历的伪数组,(item) => {
  console.log(item)
})
例子
Array.prototype.forEach.call(lis,(item) => {
  const li = item.clientHeight
  top += li
  this.tops.push(top)
})
```



## 添加响应式属性

给响应式对象添加一个属性，该属性默认不是响应式的，因此操作界面的时候界面不会有变化

例：foods.count = 1

给响应性对象添加一个属性，并且该属性是响应式，能够数据驱动视图

```plain
Vue.set(foods,"count",1)
```



## 节流防抖

防抖debounce/节流throttle

```plain
import debounce from 'lodash/debounce'
import throttle from 'lodash/throttle'
防抖
getNewCaptcha: debounce(function(){
    console.log('debounce')
},1000)
节流
getNewCaptcha: throttle(function(){
    console.log('debounce')
},1000)
```



## 路由缓存

页面设计登录退出最好不要加路由缓存，否则登录的记录不会被清除，下次进入同一页面的时候还有上次登录的信息

* vue Uncaught (in promise) undefined报错

降低路由的版本

```plain
npm i vue-router@3.0 -S
```

如果有修改父组件的内容，需要$emit来修改；如果父组件只是想调用子组件的方法，那么通过$ref来调用即可



## 显示图片

后台可能没有返回的图片，如果要展示图片需要先判断一下有否有图片的内容，如果没有那就显示默认的图片



* flex

flex可以和width同时使用

```
.cate_list{
  display: flex;
  flex-wrap: wrap;
  .list_item{
     width: 33.33%;
   }
}
```



## 节约性能

data中只存放要使用的数据，多余的数据需要过滤掉

webp格式的图片iPhone可能无法显示

## 内容加载完成显示显示{{}}

```vue
<style>
    [v-clock]:{
        display: none
    }
</style>
<template>
	<div id="app" v-clock>
        ....
    </div>
</template>
```



## 过滤器转换

```js
filters:{
    fmtNum(val){
        return ['壹','贰','叁','肆'][val]
    }
}
```



## 解析地址栏参数

```js
function getUrlParams(){
    let obj = {}
    // 判断是否有值
    if(!location.search) return obj
    let queryStrArr = location.search.replace('?', '').split('&')
    queryStrArr.forEach(item =>{
        let arr = item.split('=')
        obj[arr[0]] = arr[1]
    })
    return obj
}
```



## 星星评分效果

```vue
<template>
	<i class="iconfont" :class="item <= tempScore ? icon-star : icon-star1" v-for="item in count" @mouseenter="tempScore = item" @mouseleave="tempScore = score" @click="score = item"></i>
</template>
<script>
export default{
    data(){
        return{
            count:10, // 总分
            score: 5, // 得分
            tempScore: 5 // 临时得分
        }
    }
}
</script>
```





## 同时编辑多个值

## 不能选择相同的查询条件

双重for循环才能判断查询条件有没有一样



## 给相同的名字加后缀

```js
// 同名时自动补位
let index=1;
let indexFlag = 0
arr.map((elm)=>{
  if(elm.name === this.listFrom.name){
    indexFlag = 1
  }else if(elm.name.search(new RegExp(eval("/"+ this.listFrom.name+'_[0-9]*'+'/')))!=-1){ // 匹配到有_的值
    index++;
    indexFlag = 2
  }
})
switch(indexFlag){
  case 1:
    this.listFrom.name = this.listFrom.name + '_1';
    break;
  case 2:
    this.listFrom.name = this.listFrom.name + '_' + index;
    break;
  default:
    break;
}
```



## 动态计算client Height

```js
data(){
    return{
        height: document.documentElement.clientHeight - 60
    }
}
```

## [上传文件需要携带请求头](https://www.cnblogs.com/yuyujuan/p/10867557.html)

```js
let config = {
    headers: {
      'Content-Type': 'multipart/form-data', // 记得修改携带的请求头
      'Authorization': this.token // 看情况需要
    }
  };
  this.axios.post(apidate.uploadEnclosure,formData,config)
    .then((response) => {
        if(response.data.info=="success"){
            this.$message({
                type: 'success',
                message: '附件上传成功!'
            });
        }
    })
```



## 删除table中的tr

需要找到他们的父节点移除才算移除成功

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .table,
    .table tr,
    .table td {
      border: 1px solid #000000;
    }

    .table td {
      width: 80px;
    }

    .table input {
      outline: none;
      border: 0;
      background-color: rgba(0, 0, 0, 0);
    }
  </style>
</head>

<body>
  <div class="container">
    <div id="tables">
      <div>
        <button onclick="deleteTr()">删除</button>
      </div>
      <table id="table" class="table" cellspacing="0">
        <tr>
          <td><input type="checkbox" class="checkbox"></td>
          <td>
            <span>11</span>
          </td>
          <td>
            <span>22</span>
          </td>
          <td>
            33
          </td>
        </tr>
        <tr>
          <td><input type="checkbox" class="checkbox"></td>
          <td>
            <span>22</span>
          </td>
          <td>
            <span>33</span>
          </td>
          <td>
            <canvas id="myCanvas" width="10" height="5" style="border:1px solid #000000;">
          </td>
        </tr>
      </table>
    </div>
  </div>
</body>
<script>
  function deleteTr() {
    var box = document.getElementsByClassName('checkbox');
    var len = box.length;
    var parent = null;
    for (var i = len - 1; i > -1; i--)
      if (box[i].checked) {
        parent = box[i].parentNode.parentNode;
        parent.remove();
      }
  }
</script>
</html>
```



## import和export

方式一：

```js
// 导出
export const LOGIN_NAME = 'login_user'
// 导入
import {LOGIN_NAME} from './aa.js'

```



方式二：

```js
// 导出
export default{
    
}
// 导入
import 
```



方式三：

```js
import * as Key from './aa.js' // 导出所有变量合并到key中
export default{
    data(){
        return{
            key: Key
        }
    }
}
```





## [导出excel对象数组为二维数组](https://www.bilibili.com/video/BV1SZ4y1H7dV?p=7)

## [canvas导出海报](https://www.bilibili.com/video/BV11f4y1R7GJ?p=68)

## [drag事件实现穿梭框](https://www.bilibili.com/video/BV137411J74J?p=71)

## [进度条](https://www.bilibili.com/video/BV137411J74J?p=75)

app页面

```vue
<template>
	<div id="app">
    	<div id="progress-bar"></div>
        <router-view></router-view>
    </div>
    </div>
</template>
<style>
    #progress-bar{
        height: 5px;
        background: blue;
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        animation: grow 1s infinite forwards;
        display: none;
    }
    
    @keyframes grow{
        from:{
            width: 0;
        }
        to:{
            width: 100vw;
        }
    }
</style>
```

router页面

```js
const router = new VueRouter({ ... })
router.beforeEach((to, from, next) => {
  let bar = document.getElementById('progress-bar')
  if(bar) bar.style.display = 'block'
  setTimeOut(() => { next() })
})
router.afterEach((to, from) => {
  let bar = document.getElementById('progress-bar')
  if(bar) bar.style.display = 'none'
})
```



## 对象转字符串

```js
export const convertObj2Str = obj => {
    if(!obj) return ""
    return Object.keys(obj).map(item => {
        return item + '=' + obj[key]
    }).join('&')
}
```

## [音频可视化](https://www.bilibili.com/video/BV1Gv411C7vQ?p=88)

## [文件上传及进度显示](https://www.bilibili.com/video/BV1Gv411C7vQ?p=74)





# vue3

## 404 页面的路由配置

需要使用正则来匹配(放到所有路由的最后面!!!)

```js
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue'),
  },
  {
    path: '/:catchAll(.*)',
    name: '/404',
    component: () => import('../views/404.vue'),
  },
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes,
})

export default router
```

## 获取组件的实例 getCurrentInstance【开发环境失效!!!】

```js
// @ts-ignore
const { ctx } = getCurrentInstance() // 在setup函数中没有this
```

#### 获取当前组件根元素

```js
<template>
  <div id="app" ref="root">
	<p class="child"></p>
  </div>
</template>

<script>
import { ref, onMounted} from 'vue'
export default {
  name: 'App',
  setup() {
	const root = ref(null)
	onMounted(() => {
		console.log(root.value)
	})
  }
}
</script>
```

#### 子组件向父组件通信

```js
<script>
export default {
  name: 'App',
  setup(props, context) {
	function change() {
		context.emit('valueChange', 3)
	}
  }
}
</script>
```

#### 获取 Vuex 对象

```js
<script>
import { onMounted} from 'vue'
import { useStore} from 'vuex'
export default {
  name: 'App',
  setup(props, context) {
  	const store = useStore()
	onMounted(() => {
		console.log(store.name)
		store.commit('show')
	})
  }
}
</script>
```

## axios 搭配 ts 封装且全局挂载

```js
main.js
import axios from './http'

// 全局挂载axios
app.config.globalProperties.$axios = axios

http.ts
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios'
import { ElLoading } from 'element-plus'

let loading: any

const startLoading = () => {
  interface Options {
    lock: boolean;
    text: string;
    background: string;
  }

  const options: Options = {
    lock: true,
    text: '加载中...',
    background: 'rgba(0,0,0,0.7)',
  }
  loading = ElLoading.service(options)
}

const endLoading = () => {
  loading.close()
}

// 请求拦截
axios.interceptors.request.use((config: AxiosRequestConfig) => {
  // 加载
  startLoading()
  return config
})

// 响应拦截
axios.interceptors.response.use(
  (response: AxiosResponse<any>) => {
    // 结束loading
    endLoading()
    return response
  },
  (error) => {
    // 结束loading
    endLoading()
    // 错误提醒
    return Promise.reject(error)
  }
)

export default axios
```

## 获取 route 和 router

```js
import { useRouter, useRoute } from 'vue-router'
const router = useRouter()
const route = useRoute()

router.push('/')
```

## 百度编辑器 Ueditor

在 public 中下载一个 ueditor 静态文件，再下载 vue 中使用 ueditor 的插件

```js
npm install vue-ueditor-wrap
```

[详情]([src/view/video/editor/ueditor.vue · yx/plugin_demo - 码云 - 开源中国 (gitee.com)](https://gitee.com/yx102/plugin_demo/blob/master/src/view/video/editor/ueditor.vue))

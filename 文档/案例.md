# 案例

## 修改下载源

```shell
npm config set registry https://registry.npm.taobao.org
# 下载sass依赖失败
npm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/ -g
```



## 登录后跳转回原界面

route

```js
router.beforeEach((to, from, next) => {
  if (from.name == 'Login') {
    // 如果不需要权限校验，直接进入路由界面
    next()
  } else if (to.meta.requireAuth) {
    // 判断该路由是否需要登录权限
    if (localStorage.getItem('token')) {
      // 获取当前的token是否存在
      next()
    } else {
      alert('请登录后再访问')
      next({
        path: '/login', // 将跳转的路由path作为参数，登录成功后跳转到该路由
        query: { redirect: to.fullPath },
      })
    }
  } else {
    // 如果不需要权限校验，直接进入路由界面
    next()
  }
})
```

login

```js
// 	请求结束后，判断地址栏是否有跳转地址，如果有跳转到对应页面，没有则跳转至首页
if (this.$route.query.redirect) {
  //如果存在参数
  let redirect = this.$route.query.redirect
  this.$router.replace(redirect) //则跳转至进入登录页前的路由
} else {
  this.$router.replace('/') //否则跳转至首页
}
```

## 401 错误

需结合 `router.beforeEach` 使用

```js
axios.interceptors.request.use((config) => {
  // 将json格式请求体转换为urlencode
  const { method, data } = config
  if (method.toLowerCase() === 'post' && data instanceof Object) {
    // 此处要转成urlencode模式，不是转成对象模式
    config.data = qs.stringify(data)
  }

  // 判断页面是否需要携带token才能请求
  if (config.headers.needToken) {
    const token = JSON.parse(localStorage.getItem('token_key'))
    if (token) {
      config.headers.Authorization = token
    }
  }
  return config
})

// Add a response interceptor
axios.interceptors.response.use(
  (response) => {
    //直接返回，作为下一个成功结果的回调
    return response.data
  },
  (error) => {
    // 判断是什么错误
    const { response, message } = error
    // 1. token超时
    if (response.status === 401) {
      // 调用退出登录的方法
      store.dispatch('resetUser')
      if (router.currentRoute.path !== '/login') {
        Toast(message)
        router.push('/login')
      }
    }

    // 2. 一般请求错误
    else {
      Toast('请求错误' + message)
    }

    return new Promise(() => {})
  }
)

axios.interceptors.response.use(
  function (response) {
    return response
  },
  function (error) {
    if (error.response.status == 401 || error.response.status == 402) {
      router.push('/login')
      Vue.prototype.$msg.fail(error.response.data.message)
    }
    return Promise.reject(error)
  }
)
```

## router 页面使用封装的组件

router.js

```js
import { Toast } from 'mint-ui
Toast(message)
```

或

main.js

```js
import vant from 'vant'
import { Toast } from 'vant'
import 'vant/lib/index.css'
Vue.prototype.$msg = Toast
```

router.js

```js
Vue.prototype.$msg.fail(error.response.data.message)
```

## 记住密码

![1590388030771](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1590388030771.png)

**功能**

1.记住密码勾选，点登陆时，将账号和密码保存到 cookie，下次登陆自动显示到表单内 2.不勾选，点登陆时候则清空之前保存到 cookie 的值，下次登陆需要手动输入

> 通过存/取/删 cookie 实现的；每次进入登录页，先去读取 cookie，如果浏览器的 cookie 中有账号信息，就自动填充到登录框中，存 cookie 是在登录成功之后，判断当前用户是否勾选了记住密码，如果勾选了，则把账号信息存到 cookie 当中，效果图如上：

需要安装 `js-base64` 包

```shell
npm install --save js-base64
```

实现代码

```vue
<template>
  <form class="main">
    <!-- 账号 -->
    <div class="item">
      <label for="account">账号</label>
      <input type="text" style="display:none" />
      <input type="text" v-model="loginForm.account" id="account" />
    </div>
    <!--密码-->
    <div class="item">
      <label for="password">密码</label>
      <input type="password" style="display:none" />
      <input type="password" v-model="loginForm.password" id="password" />
    </div>
    <!-- 记住密码 -->
    <div class="item">
      <label>记住密码</label>
      <input type="checkbox" v-model="loginForm.remember" />
    </div>
    <!--登录按钮-->
    <button @click="submit">登录</button>
  </form>
</template>

<script>
// 引入base64
import { Base64 } from 'js-base64'
export default {
  data() {
    return {
      // 登陆表单
      loginForm: {
        account: '',
        password: '',
        remember: '',
      },
    }
  },
  created() {
    // 在页面加载时从cookie获取登录信息
    let account = this.getCookie('account')
    let password = Base64.decode(this.getCookie('password'))
    // 如果存在赋值给表单，并且将记住密码勾选
    if (userName) {
      this.loginForm.account = account
      this.loginForm.password = password
      this.loginForm.remember = true
    }
  },
  methods: {
    // 登录
    submit: function () {
      // 点击登陆向后台提交登陆信息
      axios.post('url', this.loginForm).then((res) => {
        // 储存token（需要封装拦截器，将token放入请求头中）
        this.setCookie('token', res.token)
        // 跳转到首页
        this.$router.push('/Index')
        // 储存登录信息
        this.setUserInfo()
      })
    },
    // 储存表单信息
    setUserInfo: function () {
      // 判断用户是否勾选记住密码，如果勾选，向cookie中储存登录信息，
      // 如果没有勾选，储存的信息为空
      if (this.loginForm.remember) {
        this.setCookie('account', this.loginForm.account)
        // base64加密密码
        let passWord = Base64.encode(this.loginForm.password)
        this.setCookie('remember', remember)
      } else {
        this.setCookie('account', '')
        this.setCookie('password', '')
      }
    },
    // 获取cookie
    getCookie: function (key) {
      if (document.cookie.length > 0) {
        var start = document.cookie.indexOf(key + '=')
        if (start !== -1) {
          start = start + key.length + 1
          var end = document.cookie.indexOf(';', start)
          if (end === -1) end = document.cookie.length
          return unescape(document.cookie.substring(start, end))
        }
      }
      return ''
    },
    // 保存cookie
    setCookie: function (cName, value, expiredays) {
      var exdate = new Date()
      exdate.setDate(exdate.getDate() + expiredays)
      document.cookie = cName + '=' + decodeURIComponent(value) + (expiredays == null ? '' : ';expires=' + exdate.toGMTString())
    },
  },
}
</script>

<style>
.main {
  width: 300px;
}
.main .item {
  display: flex;
  align-items: center;
  line-height: 30px;
}
.main .item label {
  width: 100px;
}
input:-webkit-autofill {
  -webkit-box-shadow: 0 0 0px 1000px white inset; //使用足够大的纯色内阴影覆盖黄色背景
  border: 1px solid #ccc !important;
}
</style>
```

## tabs 切换

tabs 标签横向或不用随着滚动条的高度变化而变化

```js
<li v-for="(item, index) in menu" :key="index" :class="index === currentIndex ? 'current' : ''">

export default {
  data() {
    return {
      currentIndex: 0
    };
  },
  methods: {
    changeIndex(index){
      this.currentIndex = index
      this.$emit('changeTab', index)
    }
  },
};
```

tabs 标签纵向并且需要随着高度的变化而切换

```js
<li v-for="(item, index) in menu" :key="index" :class="index === currentIndex ? 'current' : ''">

computed: {
    // 当前的选中的li
    currentIndex(){
      const index = this.tops.findIndex((item,index) => this.scrollY>=item && this.scrollY < this.tops[index+1])
      // 右侧滑动，左侧的样式还会发生改变，显示根据下标的改变来知道样式的改变
      if(index !== this.index && this.leftScroll){
        this.index = index
        // 左侧列表选中项滑到顶部
        const li = this.$refs.leftUl.children[this.index]
        this.leftScroll.scrollToElement(li, 500)
      }
      return index
    }
  },
```



## 确定值的Boolean

控制台输入确定

```plain
Boolean({}) --true
Boolean(null) --false
```

## 取值属性名

发现属性名很怪异的时候，需要通过 [] 包裹并结合""来取值

```plain
const scopeAddress = result.authSetting["scope.address"]
```

出现这种错误可以尝试try..catch..

```plain
Uncaught (in promise) thirdScriptError
{"errMsg":"chooseAddress:fail auth deny"}
Object
```

## 全选every

```javascript
cart 数组     checked 数组中的属性
const allCheck = cart.every(item => item.checked) // 返回true或false
```

## 从缓存中获取数据

如果是数组，没有的时候需要加[]

如果是对象或则字符串则可以不用加

```plain
const address = wx.getStorageSync("address")
const cartList = wx.getStorageSync(("cart")) || []
```

## 时间

```plain
var date = new Date(); //Wed May 06 2020 21:17:10 GMT+0800 (中国标准时间)
console.log(date.valueOf()); // 1588770609353
console.log(date.toString()); // Wed May 06 2020 21:18:00 GMT+0800 (中国标准时间)
console.log(date.toLocaleString()); //2020/5/6 下午4:48:41
标准时间转字符串【不会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-5-14'
new Date().toLocaleDateString().replace(/\//g,'-') 
标准时间转字符串【会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-05-14'
const y = new Date().getFullYear()
const m = (new Date().getMonth() + 1 + '').padStart(2, '0')
const d = (new Date().getDate() + '').padStart(2, '0')
const timer = y + '-' + m + '-' + d
标准时间转字符串【不会补0】
Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间) => '2020-5
字符串转标准时间 
'2020-5-14' => Sun Jun 14 2020 00:00:00 GMT+0800 (中国标准时间)
new Date('2020-5-14')
```

```js
this.setData({
  // 先将里面的数组结构出来，然后新增一个可以转换时间格式的属性
  orderList: result.orders.map(item => ({...item, create_time_cn:(new Date(item.create_time*1000).toLocaleString())}))
})
```

## 计算机票时间

如果第二天的时间为01:00，前一天的时间为23:00，相减会变负数；

解决办法：判断第二天的时间是否小于前一天的时间，如果小于那么就 +24

```js
computed: {
    rankTime(){
        // 如果接口还没有请求回来时候，先返回空
        if(!this.data.arr_time) return "";
        // 到达时间
        const arr = this.data.arr_time.split(":"); // [18, 30]
        const dep = this.data.dep_time.split(":"); // [16, 00]

        // 如果到达的小时小于出发时间的小时，说明到了第二天凌晨
        if(arr[0] < dep[0]){
            arr[0] = +arr[0] + 24;
        }
        // 到达和出发时间转换成分钟
        const end = arr[0] * 60 + +arr[1];
        const start = dep[0] * 60 + +dep[1];
        // 间隔分钟
        const dis = end - start; // 150
        // 小时
        const hours = Math.floor(dis / 60)
        // 分钟
        const min = dis % 60;
        return `${hours}时${min}分钟`;
    }
},
```



## 前台分页分段显示

前台分页：即一次请求就请求回来所有的数据

后台分页：每次只会请求会当前页的数据回来

前台分页的分段显示 ======》 需要将请求回来的数组切割成显示的段，例：第一页【0-9】，第二页【10-19】

如果需要过滤数据，不需要重新发送请求给后台，直接在前台处理数据https://www.bilibili.com/video/BV1ZC4y1s7US?p=70

```vue
https://www.bilibili.com/video/BV1ZC4y1s7US?p=63
<template>
  <div>
    <!-- flightsData.flights是航班的列表 -->
    <FlightsItem 
    v-for="(item, index) in dataList"
    :key="index"
    :item="item"/>

    <!-- 分页组件 -->
    <!-- size-change: 切换条数时候触发的事件 -->
    <!-- current-change：页数切换时候触发的事件 -->
    <!-- current-page: 当前页数 -->
    <el-pagination
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
      :current-page="pageIndex"
      :page-sizes="[5, 10, 15, 20]"
      :page-size="pageSize"
      layout="total, sizes, prev, pager, next, jumper"
      :total="total"
    >
    </el-pagination>
  </div>
</template>

<script>
export default {
  name: "",
  data() {
    return {
      fightData: {}, // 总数据
      // 分页的变量
      pageIndex: 1,
      pageSize: 5,
      total: 0,
      dataList: [] // 存放当前页数据
    };
  },
  methods: {
    // 发送请求获取数据
    getData(){
      // 总数据
      this.filgthsData = res.data
      // 显示第一页的五条数据
      this.dataList = this.filgthsData.flight.slice(0,5)
    },
    // 分页切换条数时候触发
    handleSizeChange(val) {
      // 修改显示的条数
      this.pageSize = val;
      // 重新加载数据
      this.setDataList()
    },

    // 切换页数时候触发
    handleCurrentChange(val) {
      // 修改当前的页面
      this.pageIndex = val
      // 重新加载数据
      this.setDataList()
    },

    // 设置机票列表的数据
    setDataList(arr){
      // 在总列表中截取出当前页的数据
      this.dataList = this.filgthsData.filghts.slice((this.pageIndex - 1) * this.pageSize,this.pageIndex * this.pageSize)
    }
  }
};
</script>
<style lang="less" scoped></style>
```



## 图片下间隙

```plain
img{
   vertical-align: middle;
}
```

## 移动端touch

```plain
1. touch是移动端的触摸事件 而且是一组事件
2. touchstart   当手指触摸屏幕的时候触发
3. touchmove    当手指在屏幕来回的滑动时候触发
4. touchend     当手指离开屏幕的时候触发
5. touchcancel  当被迫终止滑动的时候触发（来电，弹消息）
6. 利用touch相关事件实现移动端常见滑动效果和移动端常见的手势事件
使用touch:
1.绑定事件：box.addEventListener('touchstart',function (e) { });
2.事件对象：
名字：TouchList------触摸点（一个手指触摸就是一个触发点，和屏幕的接触点的个数）的集合
changedTouches    改变后的触摸点集合
targetTouches     当前元素的触发点集合
touches           页面上所有触发点集合
3.触摸点集合在每个事件触发的时候会不会去记录触摸
changedTouches 每个事件都会记录
targetTouches，touches 在离开屏幕的时候无法记录触摸点
4.分析滑动实现的原理：
4.1 就是让触摸的元素随着手指的滑动做位置的改变
4.2 位置的改变：需要当前手指的坐标
4.3 在每一个触摸点中会记录当前触摸点的坐标 e.touches[0] 可以拿到第一个手指触摸点
4.4 clientX clientY      基于浏览器窗口（视口）
4.4 pageX   pageY        基于页面（视口）
4.4 screenX screenY      基于屏幕
```

## 定时器interval

如果是遇到可能有负数的情况，先--，然后在判断是否需要移除

```plain
 const timer = setInterval(() => {
        this.countdowmTime --   // 先减后判断是否移除
        if(this.countdowmTime <= 0){
          clearInterval(timer)
        }
}, 1000);
```

## 三目运算符

	条件是否成立，条件成立为结果1，否则为结果2

```plain
int a = 1, b = 2, z;
z = a > b ? a : b;  //去了括号
console.log(z) // 2
```

## 数组拼接

```plain
使用concat拼接(括号里是新的内容)
this.comments = this.comments.concat(res.data.message)
使用扩展运算符拼接(前面的是原数组，后面的是新的内容)
this.goodsList:[...this.goodsList,...res.goods]
使用push和扩展运算符
this.goodList.push(...res.goods)
```

使用第一种的

```plain
if (res.data.status == 0) {
    //拼接评论数据，而不是覆盖评论数组
    res.data.message.length ? res.data.message : Toast("没有更多数据")
    this.comments = this.comments.concat(res.data.message)
    console.log(res.data.message)
}
```



## 自动聚焦

```plain
@opened="$refs.name.focus()"
触发事件="$refs.xxx.focus()"
```

## 单向绑定vs双向绑定

```javascript
单向数据绑定
<input :value="user.name" @input="inputName = $event"/> 
:value="data中的数据"
$event 标识事件参数，是Vue提供的，可以直接获取到input的值
@input="inputName = $event"
事件中更新
this.user.name = this.inputName
双向数据绑定
v-model="data中的数据"
```


## 含变量的请求方法

[变量]:value

```js
async saveProfile (field, value) {
  this.$toast.loading({
    duration: 0, // 持续时间，0表示持续展示不停止
    forbidClick: true, // 是否禁止背景点击
    message: '保存中...' // 提示消息
  })
  try {
    await updateUserProfile({
      [field]: value
    })
    this.$toast.success('保存成功')
    this.user[field] = value
    globalBus.$emit('user-update')
    this.isEditGenerShow = false
  } catch (err) {
    this.$toast.success('保存失败')
    return Promise.reject(err)
  }
},
```

## 不调整css直接触发隐藏元素点击事件

```plain
<input type="file" hidden accept="image/*" ref="file" />
<button @click="uploadFile">上传</button>
uploadFile(){
  this.$refs.file.click()
}
```

## better-scroll不能与sticky共存

## 获取组件的元素

```plain
console.log(this.$refs.tabcontrol.$el)
```

## 监听组件的点击

```
<BackTop @click.native="backClick" v-show="scrollY > 1000" />
```

## 复杂的数据中取数据

```plain
在index.js中
export class Goods {
	  constructor(itemInfo, columns, services) {
	    this.title = itemInfo.title;
	    this.columns = columns;
	    this.services = services;
	  }
}
请求数据
import {Goods} from './api'
this.goods = new Goods(data.itemInfo, data.columns, data.shopInfo.services);
```

## 判断数组对象是否为空

```plain
数组
arr.length > 0
对象
Object.keys(goods).length !== 0
```

## 直接使用数组的最后一个

```plain
{{goods.services[goods.services.length-1].name}}
```


## 使用数组的其中几个值

```plain
遍历除数组最后一个值
v-for"item in 10" item => 1,2...10
<div class="info-service">
<span class="info-service-item" v-for="index in goods.services.length-1" :key="index">
<img :src="goods.services[index-1].icon">
<span>{{goods.services[index-1].name}}</span>
</span>
</div>
```





## 城市列表的数据



## 接口可传可不传的params

如果用户传了就使用params对象，如果用户没有传就使用{}

```plain
export default reqdata(params = {}){
  url: '...',
  params
}
```

## 并发进行的请求

```plain
import {getArtical} from '@/api/article'
import {getTags} from '@/api/tag'
并发进行
const [res1,res2] = await Promise.all([getArtical(),getNews()])

分开请求
const {data} = await getArtical()
const {data: tagData} = await getNews()
```


## 判断添加到数组中的内容是否重复





## 共用同一个方法



```js
handleClick(type){
    // 默认选中城市列表第一个
    // if(this.cities.length > 0){
    //     if(type === "depart"){
    //         this.form.departCity = this.cities[0].value;
    //         this.form.departCode = this.cities[0].sort;
    //     }
    //     if(type === "dest"){
    //         this.form.destCity = this.cities[0].value;
    //         this.form.destCode = this.cities[0].sort;
    //     }
    // }  
    // 另一种写法
    if(this.cities.length === 0) return;
    this.form[type + "City"] = this.cities[0].value;
    this.form[type + "Code"] = this.cities[0].sort;
        },
```



## 历史记录

### 保存到localstorage

点击查询按钮的时候，发送请求查询结果，同时将本次查询需要显示的参数存放到一个数组中

```js
<el-button style="width:100%;"  type="primary"  icon="el-icon-search" @click="handleSubmit">
    搜索
</el-button>

handleSubmit(){
    const historyList = JSON.parse(localStorage.getItem('history') || '[]')
    // 要求：不要有重复历史记录、最新的排在最前面
    const index = this.historyList.indexOf(searchword)
    if (index !== -1) {
    	this.historyList.splice(index, 1)
    }
    historyList.unshift('需要存储的参数')
    localStorage.setItem('history',JSON.stringify(historyList))
}
```



### 保存到vuex

组件中

```js
<el-button style="width:100%;"  type="primary"  icon="el-icon-search" @click="handleSubmit">
    搜索
</el-button>
// 保存到store
this.$store.commit("air/setHistory", this.form);
```

vuex文件夹下的文件

```js
export const state = () => {
    return {
        // 搜索的历史记录
        history: []
    }
}

export const mutations = {
    // 设置history的值,data是搜索表单的对象
    setHistory(state, data){
        // 把最新的记录追加到第一个
        state.history.unshift(data);
    }
}
```

## 前端生成二维码

https://github.com/soldair/node-qrcode

https://github.com/soldair/node-qrcode/tree/master/examples

下载

```js
npm install --save qrcode
```

引入

```js
import QRCode from 'qrcode'
```

使用

```vue
<template>
<div class="qrcode">
    <!-- 二维码 -->
    <canvas id="qrcode-stage"></canvas>

    <p>请使用微信扫一扫</p>
    <p>扫描二维码支付</p>
</div>
</template>
<script>
export default{
    methods:{
        getInfo(){
            // 请求完成数据获取到订单号后
            // 获取canvas元素
            const canvas = document.querySelector("#qrcode-stage");
            QRCode.toCanvas(canvas, 需要转化的URL, {
                width: 200
            });
        }
    }
}
</script>
```



## 封装 better-scroll 的使用

**轮播图横向滑动要先给ul加width，同时要开启scrollX： true**

better-scroll 的模板

```vue
<template>
  <div class="wrapper" ref="wrapper">
    <div class="content">
      <slot></slot>
    </div>
  </div>
</template>
<script>
import BScroll from "better-scroll";
export default {
  data() {
    return {
      scroll: null
    };
  },
  props: {
    probeType: {
      type: Number,
      default: 0
    },
    pullUpLoad: {
      type: Boolean,
      default: false
    },
    pullDownRefresh: {
      type: Boolean,
      default: false
    },
    scrollX:{
      type: Boolean,
      default: false
    }
  },
  methods: {
    _initScroll() {
      if (!this.scroll) {
        this.scroll = new BScroll(this.$refs.wrapper, {
          scrollX: this.scrollX
          click: true,
          mouseWheel: true,
          probeType: this.probeType,
          pullUpLoad: this.pullUpLoad,
          pullDownRefresh: this.pullDownRefresh
        });

        if (this.probeType !== 0) {
          // 监测滚动位置
          this.scroll.on("scroll", position => {
            this.$emit("scrollPosition", position);
          });

          // 监测滚动条最末端的位置
          this.scroll.on("scrollEnd", position => {
            this.$emit("scrollEndPosition", position);
          });
        }

        if (this.pullUpLoad) {
          this.scroll.on("pullingUp", () => {
            this.scroll.finishPullUp()
            this.$emit("pullingUp");
          });
        },

        if (this.pullDownRefresh) {
          this.scroll.on("pullingDown", () => {
            this.$emit("pullingDown");
          });
        },
      }
    },

    // 到达指定的位置
    scrollTo(x, y, time = 300) {
      this.scroll && this.scroll.scrollTo(x, y, time);
    },

    // 到达指定的元素
    scrollToElement(el,time = 300) {
      this.scroll && this.scroll.scrollToElement(el, time);
    },

    // 刷新
    refresh() {
      this.scroll && this.scroll.refresh();
    },

    // 重复加载
    finishPullUp() {
      this.scroll && this.scroll.finishPullUp();
    }
  },
  mounted() {
    this.$nextTick(() => {
      this._initScroll()
    })
  }
};
</script>
```

组件中使用

> 引入注册组件，给 scroll 设置需要滚动的范围
>
> 将需要滚动的内容放到`scroll`中包裹起来
>
> 如果要开启横向滚动，父组件传值给子组件`:probeType="3"`
>
> 如果要监听滚动距离，父组件传值给子组件`:scrollX="true"`
>
> 如果要上拉加载，父组件传值给子组件`:pullUpLoad="true"`并监测滚动位置事件`@scrollPosition="scrollPosition"`和上拉加载事件`@pullingUp="loadMore"`
>
> 如果下拉刷新，父组件传值给子组件`:pullDownRefresh="true"`并监听下拉刷新事件`@pullingDown="pullingDown"`
>
> 如果直接达到某一个地方，父组件调用子组件方法`this.$refs.scroll.scrollTo(0, this.scrollY, 0)`,点击达到指定位置或进入当前页面回到对应的位置
>
> 如果到达指定的元素位置，父组件调用子组件方法`this.$refs.scroll.scrollToElement(li, 500)`,
>
> 如果重置滚动条高度，父组件调用子组件方法`this.$refs.scroll && this.$refs.scroll.refresh()`,一般用于 mounted 挂载时重置，或等图片加载完成后重置

```vue
<template>
  <scroll class="homeScroll" ref="homeScroll" :probeType="3" :pullUpLoad="true" @scrollPosition="scrollPosition" @pullingUp="loadMore">
    <!-- 轮播图 -->
    <home-swipe :banner="banner" class="home_swiper"></home-swipe>
    <!-- 推荐列表 -->
    <home-recommend :recommend="recommend"></home-recommend>
  </scroll>
</template>

<script>
methods:{
    scrollPosition(position) {
      this.scrollY = Math.abs(position.y);
    },

    loadMore() {
      this.getGoodsList(this.currentType);
    },

    // 请求的下拉页面事件
    async getGoodsList(type) {
      // 在不同的类型上页码值随着滑动而增加
      const page = this.goods[type].page + 1;
      const res = await reqHomeGoodsList(type, page);

      if (res.success) {
        this.goods[type].list.push(...res.data.list);
        this.goods[type].page += 1;
      }
    }
}
</script>

<style scoped lang="less">
.homeScroll {
  height: calc(100% - 93px); /*calc两边需要有空格，否则实现不了*/
  overflow: hidden;
}
</style>
```

### 图片导致的滚动 bug

**请求的数据中图片没加载完成不能形成滚动**

解决办法：监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次 refresh()

**监听图片加载完成**

```html
原生的js监听图片: img.onload = function() {}
<img onload="function()" {} />
Vue中监听: @load='方法'
<img @load="loadImg" />

<img :src="goodItem.img" v-if="goodItem.img" @load="imageLoad" />

监听加载完成后刷新滚动条的高度 loadImg: debounce(function(){{ this.$refs.rightScroll && this.$refs.rightScroll.refresh() },
```

### 获取 offsetTop 不正确的 bug

原因：图片没有加载完成就获取 offsetTop，导致不正确

解决办法：待图片加载完成再获取

```html
<img :src="goodItem.img" v-if="goodItem.img" @load="imageLoad" />

监听加载完成后刷新滚动条的高度 loadImg: debounce(function(){{ this.tabHeight = this.$refs.tabcontrol.$el.offsetTop },
```

### 导航条吸顶

导航条滚动到一定距离之后吸顶,在 scroll 滚动外侧放置一个隐藏的 tab 栏，到达指定位置后 tab 栏显示，原来的 tab 栏隐藏

```vue
<template>
  <!-- 到达指定位置出现的tab栏 -->
  <tab-control v-show="isShowTab"></tab-control>

  <scroll>
    <!-- 轮播图 -->
    <home-swipe></home-swipe>

    <div>
      <!-- tab栏 -->
      <tab-control v-show="!isShowTab"></tab-control>
    </div>
  </scroll>
</template>
<script>
computed:{
    isShowTab() {
      if (this.scrollY > this.tabHeight) {
        return true;
      } else {
        return false;
      }
    },
}
</script>
```

## 上拉刷新下拉加载

### 上拉加载

滚动条触底 开始加载下一页数据

1. 找到滚动条触底事件

2. 判断还有没有下一页数据

3. 获取到总页数 计算总条数

    总页数 = Math.ceil(总条数 / 页容量 pagesize)【总页数 = Math.ceil( 23 / 10 ) = 3】

4. 获取到当前的页码 pagenum

    判断一下 当前的页码是否大于等于 总页数 【if(totalPage>=this.pagenum)】

    表示 没有下一页数据

5. 假如没有下一页数据 弹出一个提示

6. 假如还有下一页数据 来加载下一页数据
   1 当前的页码 ++

    2 重新发送请求 this.getGoodsList()

    3 数据请求回来 要对 data 中的数组 进行 拼接 而不是全部替换！！！

    【goodsList:[...this.data.goodsList,...res.goods] 或 this.list.**push**(...res.data.list)】

### 下拉刷新页面

1. 触发下拉刷新事件
2. 重置 数据 数组 【goodsList: []】
3. 重置页码 设置为 1
4. 重新发送请求 this.getGoodsList()
5. 数据请求回来 需要手动的关闭 等待效果【在请求成功的函数写关闭代码】

## 加入购物车

1. 先绑定点击事件
2. 获取 缓存/vuex 中的购物车数据 数组格式
3. 先判断【findIndex】当前的商品是否已经存在于 购物车
4. 已经存在 修改商品数据 执行购物车数量++ 重新把购物车数组 填充回缓存中
5. 不存在于购物车的数组中 直接给购物车数组添加一个新元素 push 新元素 带上 购买数量属性 num 重新把购物车数组 填充回缓存中
6. 弹出提示添加到购物车成功

### js 的方法

```js
handleCartAdd() {
  // 1 获取缓存中的购物车 数组
  let cart = JSON.parse(localStorage.getItem('cart') || '[]')
  // 2 判断 商品对象是否存在于购物车数组中
  let index = cart.findIndex(v => v.goods_id === this.GoodsInfo.goods_id);
  if (index === -1) {
    //3  不存在 第一次添加
    this.GoodsInfo.num = 1;
    this.GoodsInfo.checked = true;
    this.cartList.push(this.GoodsInfo);
  } else {
    // 4 已经存在购物车数据 执行 num++
    this.cartList[index].num++;
  }
  // 5 把购物车重新添加回缓存中
  localStorage.setItem("cart", JSON.stringify(cart));
},
```

### vuex 的方法 1

```js
actions: {
 addToCart({commit, state}, good){
    const index = state.cartList.findIndex(item => item.iid === good.iid)
    if(index === -1){
      commit(ADD_CART, good)
    }else{
      commit(ADD_COUNT, index)
    }
  },
}
mutations: {
  [ADD_CART](state, good){
    Vue.set(good, "count", 1)
    state.cartList.push(good)
  },

  [ADD_COUNT](state, index){
    state.cartList[index].count ++
  },
}
```

### vuex 的方法 2

```js
actions: {
 addToCart({commit, state}, good){
  let oldProduct = null
  state.cartList.some(item => {
    if(item.iid === good.iid){
      oldProduct = item
    }
  })
  if(oldProduct){
    commit(ADD_COUNT, good)
  }else{
    commit(ADD_CART, good)
  }
}
mutations: {
  [ADD_CART](state, good){
    Vue.set(good, "count", 1)
    state.cartList.push(good)
  },

  [ADD_COUNT](state, good){
    good.count ++
  },
}
```

## 商品收藏

页面`created`时，读取缓存中的商品收藏的数据

1. 判断当前商品是不是被收藏
2. 是 ------------> 改变页面的图标
3. 不是
   1. 点击商品收藏按钮
   2. 判断该商品是否存在于缓存数组中 【some】 请求完成才可以判断是否有该商品
   3. 已经存在 把该商品删除 【splice】
   4. 没有存在 把商品添加到收藏数组中 存入到缓存中即可 【push】

### 方式一

优点：不需要单独用一个数组来保存是否被收藏

在获取到商品列表数据后，给每个商品添加一个标识`isCollect:false`后再将内容保存会 data 中，通过读取数据来确定是否有收藏商品；

如果有收藏`:class="{active : item.isCollect}"`

### 方式二

获取当前商品的 id，默认是给商品加收藏

```js
<div @click="handelCollect">收藏</div>

data: {
  // 当前商品是否被收藏
  isCollect:false,
  collectList:[]
},
mounted(){
  async getGoodsDetail(){
    const result = await request({url: '/goods/detail', data:this.queryInfo})
    this.goodsObj = result

    // 加载缓存中的商品收藏的数据
    this.collectList = JSON.parse(localStorage.getItem("collectList") || '[]')
    // 判断缓存中是否有该商品
    this.isCollect = collectList.some(item => item.goods_id === this.goodsObj.goods_id)
   },
}

methods:{
  // 商品收藏
  handelCollect(){
    // 1 判断该商品是否存在于缓存数组中
    const index = this.collectList.findIndex(item => item.goods_id === this.goodsObj.goods_id)

    // 2 已经存在 把该商品删除
    if(index !== -1){
      <i class="ion-close-round" @click="deleteTag(index)"></i>
      this.isCollect = false
    }else{
      // 3 没有存在 把商品添加到收藏数组中 存入到缓存中即可
      this.collectList.push(this.goodsObj)
      this.isCollect = true
    }

    // 4. 将值存入缓存中
    localStorage.setItem("collectList", JSON.stringify(this.collectList))
  }
}
```

## 商品支付

支付按钮

先获取 token 然后，判断缓存中有没有 token

没 token 跳转到登录页面登录

有 token

1. 准备发送请求 创建订单 获取订单编号
2. 发起 预支付接口
3. 发起微信支付 wx-requestPayment
4. 查询后台 订单状态 分别提示支付成功和支付失败
5. **手动删除缓存中 已经被选中了的商品**
   let newCart=wx.getStorageSync("cart")
   newCart=newCart.filter(v=>!v.checked) // 过滤只剩下没有被选中的商品
6. 删除后的购物车数据 填充回缓存
   wx.setStorageSync("cart", newCart)
7. 再跳转页面

## 多层嵌套评论

comment_id 为当前的评论评级

如果 parent_id 有值则为回复的评论

https://www.bilibili.com/video/BV1vT4y137So?p=33

```json
[
  { "comment_id": 1, "user_id": 43, "comment_date": "04-23", "comment_content": "蜡笔小新很好看!", "parent_id": null },
  { "comment_id": 2, "user_id": 19, "comment_date": "04-24", "comment_content": "还不错哦!很好看", "parent_id": null },
  { "comment_id": 3, "user_id": 17, "comment_date": "04-25", "comment_content": "我也感觉蜡笔小新很好看", "parent_id": "1" },
  { "comment_id": 4, "user_id": 14, "comment_date": "04-26", "comment_content": "我感觉机器猫更好看一点", "parent_id": "3" },
  { "comment_id": 5, "user_id": 13, "comment_date": "04-27", "comment_content": "好看,已三连!", "parent_id": null },
  { "comment_id": 6, "user_id": 21, "comment_date": "04-26", "comment_content": "你是机器猫的粉丝吗", "parent_id": "4" },
  { "comment_id": 7, "user_id": 14, "comment_date": "04-27", "comment_content": "是的,我是机器猫的粉丝", "parent_id": "6" },
  { "comment_id": 8, "user_id": 23, "comment_date": "04-27", "comment_content": "我更喜欢白嫖!", "parent_id": "5" },
  { "comment_id": 9, "user_id": 25, "comment_date": "04-28", "comment_content": "你个白嫖怪", "parent_id": "8" }
]
```

## 歌词解析

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      p.active {
        color: red;
      }
    </style>
  </head>
  <!-- https://www.bilibili.com/video/BV1ye411p7w3?p=48 -->
  <body>
    <div id="app">
      <audio src="./mp3/2.mp3" controls ref="audio"></audio>
      <div v-for="(value, key, index) in lrcObj" :key="key" style="text-align: center;">
        <!-- 显示时：currentTime 大于当前的key， 小于下一个key ==> 设计一个key数组 -->
        <p :class="currentTime >= currentKeys[index] &&  currentTime < currentKeys[index + 1] ? 'active' : ''">{{value}}</p>
      </div>
    </div>
    <script src="./js/vue.js"></script>
    <script>
      new Vue({
        el: '#app',
        data: {
          lrc: {
            version: 1,
            lyric:
              '[by:葫芦-小-金刚]\n[00:00.000] 作曲 : 郑秋枫\n[00:01.000] 作词 : 瞿琮\n[00:07.754] 百灵鸟从蓝天飞过\n[00:25.848] 我爱你中国\n[00:44.110]\n[01:09.562] 我爱你中国\n[01:16.698] 我爱你中国\n[01:23.330] 我爱你春天蓬勃的秧苗\n[01:29.878] 我爱你秋日金黄的硕果\n[01:36.927] 我爱你青松气质\n[01:43.418] 我爱你红梅品格\n[01:50.103] 我爱你家乡的甜蔗\n[01:54.920] 好像乳汁滋润着我的心窝\n[02:04.858] 我爱你中国\n[02:12.027] 我爱你中国\n[02:19.002] 我要把最美的歌儿献给你\n[02:25.517] 我的母亲我的祖国\n[02:34.071]\n[02:46.141] 我爱你中国\n[02:52.828] 我爱你中国\n[02:59.436] 我爱你碧波滚滚的南海\n[03:05.749] 我爱你白雪飘飘的北国\n[03:13.225] 我爱你森林无边\n[03:19.760] 我爱你群山巍峨\n[03:26.110] 我爱你淙淙的小河\n[03:31.159] 荡着清波从我的梦中流过\n[03:41.374] 我爱你中国\n[03:48.376] 我爱你中国\n[03:55.123] 我要把美好的青春献给你\n[04:01.591] 我的母亲我的祖国\n[04:09.380] 啊~~~\n[04:22.596] 我要把美好的青春献给你\n[04:29.422] 我的母亲我的祖国\n',
          },
          lrcObj: {},
          currentTime: 0, // 当前播放的时间
          duration: 0, // 总时长
          currentKeys: [],
        },
        mounted() {
          this.formateLrc()
        },
        methods: {
          // 将歌词格式化为数组对象[{1:"jfkd"},{34:"jfklds"}]
          formateLrc() {
            // 去除所有的空格,"[00:12.570]难以忘记初次见你"
            const arr = this.lrc.lyric.split('\n')
            // 分开数字和歌词的正则表达
            const reg = /\[\d*:\d*(\.|:)\d*]/g
            let obj = {}
            for (let i = 0; i < arr.length; i++) {
              // 歌词时间
              const time = arr[i].match(reg)
              // 歌词文本
              const text = arr[i].replace(time, '')

              // 含有所有时间的字符串
              if (time) {
                // 将时分秒转成数字格式
                const min = Number(time[0].match(/\[\d*/i).toString().slice(1)) //"[00" => 00
                const second = Number(time[0].match(/:\d*/i).toString().slice(1)) //":34" =>34
                const currentTime = min * 60 + second
                obj[currentTime] = text
                this.currentKeys.push(currentTime)
              }
            }
            this.lrcObj = obj

            this.$nextTick(() => {
              this.addEventAudio()
            })
          },

          // 监听播放器的事件
          addEventAudio() {
            // 1. 歌曲当前播放的时间
            this.$refs.audio.addEventListener('timeupdate', () => {
              this.currentTime = this.$refs.audio.currentTime
            })
            // 2. 歌曲的总时长
            this.$refs.audio.addEventListener('canplay', () => {
              this.duration = this.$refs.audio.duration
            })
          },
        },
      })
    </script>
  </body>
</html>
```

## 城市列表

```html
<!DOCTYPE html>
<html lang="en">
  <!-- https://www.bilibili.com/video/BV1KE411s7kX?p=100 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <div v-for="item in cities" :key="item.cityId">
        <p style="background-color: aquamarine;">{{item.letter}}</p>
        <p v-for="(city, index) in item.list" :key="index">{{city.name}}</p>
      </div>
    </div>
    <script src="./js/vue.js"></script>
    <script>
      var vm = new Vue({
        el: '#app',
        data: {
          cityData: [
            {
              cityId: 110100,
              name: '北京',
              pinyin: 'beijing',
              isHot: 1,
            },
            {
              cityId: 650500,
              name: '哈密',
              pinyin: 'hami',
              isHot: 0,
            },
            {
              cityId: 320200,
              name: '无锡',
              pinyin: 'wuxi',
              isHot: 0,
            },
          ],
          cities: [],
        },
        created() {
          this.formatCity()
        },
        methods: {
          formatCity() {
            let letterArr = []
            // 选出26个字母
            for (let i = 65; i < 91; i++) {
              letterArr.push(String.fromCharCode(i))
            }
            let newCityList = []
            // 从数组中取出数据进行对比
            for (let j = 0; j < letterArr.length; j++) {
              // 过滤字母相同的数组
              const tempArr = this.cityData.filter((item) => item.pinyin.slice(0, 1) === letterArr[j].toLowerCase())
              if (tempArr.length > 0) {
                newCityList.push({
                  letter: letterArr[j],
                  list: tempArr,
                })
              }
            }
            this.cities = newCityList
          },
        },
      })
    </script>
  </body>
</html>
```

## 手机端城市列表

点击某个字母跳转到对应的位置(使用 better-scroll 中的 scrollToElement)

[参考](<[vue项目,Vue旅游网项目_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ik4y1174T?p=25)>)

## 支付页面

![1592361887347](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1592361887347.png)

- 发送请求获取订单的相关数据

```js
// 请求订单详情
const res = await this.$axios({
  url: '/airorders/' + id,
  headers: {
    Authorization: `Bearer ${this.$store.state.user.userInfo.token}`,
  },
})
this.order = res.data
```

- 是否需要形成二维码,若形成则添加

```js
// 获取canvas元素
const canvas = document.querySelector('#qrcode-stage')
QRCode.toCanvas(canvas, this.order.payInfo.code_url, {
  width: 200,
})
```

- 轮询【定时器】查接口看是否已支付，如果已经支付则取消轮询【清除定时器】，如果没有支付继续轮询

```js
// 查询付款状态
this.timer = setInterval(async () => {
  const res = await this.$axios({
    url: '/checkpay',
    method: 'POST',
    headers: {
      Authorization: `Bearer ${this.$store.state.user.userInfo.token}`,
    },
    data: {
      id: this.$route.query.id,
    },
  })
  // 获取支付状态
  const { statusTxt } = res.data
  // 支付完成之后判断
  if (statusTxt === '支付完成') {
    this.$message.success(statusTxt)
    clearInterval(this.timer)
  }
}, 3000)
```

- 如果不支付直接跳转到其他页面，需要跳转前询问，若离开则销毁当前的组件`destroyed`

```js
 // 组件销毁时候使用的，一般情况下用于清除定时器
destroyed(){
    clearInterval(this.timer);
}
```

## base64 加密

安装

```
npm install --save js-base64
```

直接使用

```js
import { Base64 } from 'js-base64'
let latin = 'dankogai'
Base64.encode(latin)
```

封装再使用

```js
processPassword(pw){
      let Base64 = require('js-base64').Base64;
      var str = Base64.encode(pw);
      if(str.length>2){
        var lp = str.substr(0,2);
        var rp = str.substr(2,str.length);
        pw = rp+lp;
      }
      return pw;
    },

 login(){
 	let password
 	password=this.processPassword(this.password);
 }
```

## 右键新建菜单

![image.png](https://pic.gksec.com/2020/10/09/0609b64e8e395/image.png)

功能：

没有打开显示完成文件夹图标

打开后显示打开的文件夹图标，子项用文档图标显示

点击右键新建

点击左键取消右键的新建模块

```vue
<template>
  <el-scrollbar class="height100 br-2" :native="false">
    <el-tree :props="props" lazy :load="loadNode" :expand-on-click-node="false" @node-click="onClickNode" class="relative">
      <span class="smallfont custom-tree-node" slot-scope="{ node, data }" @contextmenu.prevent.stop="showCreat($event, data.id)">
        <span><i :class="getTreeImg(node)" style="color:#409EFF;padding-right:5px;"></i>{{ data.name }}</span>
        <span @click="delectModules(data.id)"><i class="delModule el-icon-delete d-none" style="color:#409EFF;padding-right:5px;"></i></span>
      </span>
    </el-tree>
    <div v-if="mouseCreatVisible" :style="mouseCreatStyle">
      <el-button size="mini" @click="mouseCreat">新建</el-button>
    </div>
  </el-scrollbar>
</template>

<script>
export default {
  data() {
    return {
      activeName: 'basicInfor',
      active: 'basicInfor',
      props: {
        label: 'name',
        children: 'zones',
        isLeaf: 'hasChild',
      },
      node: [],
      resolve: function () {},
      visible: false,
      dialogVisible: false,
      params: {
        appId: '',
        id: '',
        name: '',
        description: '',
        superior: '',
        superiorName: '',
        orderNo: 0,
      },
      data: [],
      mouseCreatVisible: false, //右键新建的显示标识
      mouseCreatStyle: '', //右键新建的样式
    }
  },

  methods: {
    /**
     * 加载树下级
     */
    loadNode(node, resolve) {
      let appId = sessionStorage.getItem('appId')
      let parentId = node.data != undefined ? node.data.id : ''
      let data = []
      if (node.level === 0) {
        this.node = node
        this.resolve = resolve
        getModulesTree(appId, parentId, {
          onSucess: (response) => {
            if (response.data.errcode == 0) {
              data = response.data.data
              if (node.data != undefined) {
                return resolve([{ name: node.data.name }])
              }
              return resolve(data)
            }
          },
        })
      }
      if (node.level >= 1) {
        getModulesTree(appId, parentId, {
          onSucess: (response) => {
            if (response.data.errcode == 0) {
              data = response.data.data
              if (node.data != undefined) {
                return resolve(data)
              }
            }
          },
        })
      }
    },
    /**
     * 点击模块树节点
     * 传递给 data 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身
     */
    onClickNode(data) {
      this.$store.dispatch('rightHelpPageParams', { title: '模块信息', url: 'application/application_module_form_list_help.html' })
      console.log(data)
      let appId = sessionStorage.getItem('appId')
      this.visible = true
      this.active = 'basicInfor'
      let params = {
        appId: appId,
        moduleId: data.id,
      }
      this.$router.push({ path: '/home/softwaresdetails/basicinfor', query: { edit: true, params: params } })
    },

    showCreat(event, id) {
      this.params.superior = id
      this.mouseCreatStyle = `position:absolute;top:${event.target.offsetTop + 15}px;left:${event.x - 10}px;`
      this.mouseCreatVisible = true
    },
    mouseCreat() {
      this.mouseCreatVisible = false
      this.dialogVisible = true
    },
    getTreeImg(node) {
      let className = ''
      if (node.isLeaf) {
        className = 'el-icon-document'
      } else if (!node.expanded) {
        className = 'el-icon-folder'
      } else {
        className = 'el-icon-folder-opened'
      }
      return className
    },
  },
}
</script>
<style>
.relative {
  position: relative;
}
</style>
```



## 鼠标悬浮时显示新建

vue 中没有 hover，可以使用 css 伪类**：hover** 或者**@mouseenter @mouseleave @mouseover @mouseout** 等处理类似需求

## vue 嵌套的 iframe 控制全屏和非全屏

![image.png](https://pic.gksec.com/2020/10/10/a3b541225507f/image.png)

iframe

```html
<html>
  <button class="handleTest btn" onclick="handleTest(this)">全屏操作</button>
  <button class="closeAllScren btn" onclick="closeAllScren(this)" style="display:none">取消全屏</button>
  <script>
    function handleTest(event) {
      window.parent['handleSpanClick'](true)
      document.getElementsByClassName('handleTest')[0].setAttribute('style', 'display:none')
      document.getElementsByClassName('closeAllScren')[0].setAttribute('style', 'display:inline-block')
    }
    function closeAllScren(event) {
      window.parent['handleSpanClick'](false)
      document.getElementsByClassName('handleTest')[0].setAttribute('style', 'display:inline-block')
      document.getElementsByClassName('closeAllScren')[0].setAttribute('style', 'display:none')
    }
  </script>
</html>
```

vue

```vue
<template>
  <div v-show="activeName == 'content'">
    <iframe ref="formFormat" :src="src" width="100%" :height="iframeHeight" frameborder="0" :style="iframeStyle"></iframe>
  </div>
</template>

<script>
export default{
    data:{
     return {
        spanClick: 'handleSpanClick',
        iframeStyle:'',//iframe全屏样式
      	iframeHeightBefore:100,
     }
    }
	mounted(){
        /**
         * 动态计算页面table高度
         */
        getScollerHeight() {
          setTimeout(() => {
            let clientHeight = document.documentElement.clientHeight || document.body.clientHeight;
            //60 头部， 32 面包屑， 41 第一层页签， 40 第二层页签， 50 列表标题， 71 查询， 20 父组件外边距, 40分页, 16 外边距
            //这个组件在父组件dialog中高度给的85%，54 弹窗标题 30 弹窗底部padding 50 第一季页签 20机动距离
            this.tableHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 16;
            this.operaHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 48; //48操作列操作栏
            this.iframeHeight = clientHeight - 60 - 32 - 41 - 50 - 20 - 16;
            this.iframeHeightBefore = clientHeight - 60 - 32 - 41  + "px";
          }, 100);
        }

		if (this.$route.query.params.showType == "pc")
		this.src = `./formHtml/fcktest2.html?contextPath=${getContextPath()}`
    	else
    	this.src = `./formHtml/formbuilder/index.html?contextPath=${getContextPath()}`
	},
	created(){
        //操作iframe的全屏事件
        window[this.spanClick]=(isScresn)=>{
          this.allScrean(isScresn);
        }
  	},
  	methods:{
  		allScrean(isScresn){
          if(isScresn ){
            this.iframeStyle='position:absolute;top:0;left:0;right:0;bottom:0;z-index:10';
            this.iframeHeight='100%';
          }else{
            this.iframeStyle='';
            this.iframeHeight=this.iframeHeightBefore;
          }
        },
  	}
}
</script>
```



## 取多层结3构的对象报错

**取一个对象三层及三层以上的内容**会报错，可以通过 v-if 来解决

如果在 undefined 中读取不到 length，尝试通过 children 的方式来获取，证明mounted中加载 better-scroll 的时间早了，可以增加判断条件来确定什么时候初始化better-scroll；



## 过滤评论内容

子组件想要改变父组件的状态内容，用子组件向父组件传值

过滤判断条件：先确定【全部 / 推荐 / 吐槽】，再确定【是否只看有评论的内容】

```plain
filterRatingsComment(){
      /**
       * 情况1： 
       * data的activeType： 0 / 1 / 2
       * ratings的rateType： 0 / 1
       * => activeType === 2 || activeType ===  rateType
       * 
       * 
       * 情况2
       * data的onlyText： true / false
       * ratings的text: 有 / 无
       * => !onlyText || onlyText && text.length > 0
       * 
       */
      const {onlyText, activeType, ratings} = this
      return ratings.filter((item) => {
        return (activeType === 2 || activeType ===  item.rateType) && (!onlyText || onlyText && item.text.length > 0)
      })
    }
```



## 伪数组转真数组遍历

伪数组如果想要实现forEach方法，可以通过改变this指向

```plain
模板：
Array.prototype.forEach.call(需要遍历的伪数组,(item) => {
  console.log(item)
})
例子
Array.prototype.forEach.call(lis,(item) => {
  const li = item.clientHeight
  top += li
  this.tops.push(top)
})
```



## 添加响应式属性

给响应式对象添加一个属性，该属性默认不是响应式的，因此操作界面的时候界面不会有变化

例：foods.count = 1

给响应性对象添加一个属性，并且该属性是响应式，能够数据驱动视图

```plain
Vue.set(foods,"count",1)
```



## 节流防抖

防抖debounce/节流throttle

```js
import debounce from 'lodash/debounce'
import throttle from 'lodash/throttle'
// 防抖
getNewCaptcha: debounce(function(){
    console.log('debounce')
},1000)
// 节流
getNewCaptcha: throttle(function(){
    console.log('debounce')
},1000)
```



## 路由缓存

页面设计登录退出最好不要加路由缓存，否则登录的记录不会被清除，下次进入同一页面的时候还有上次登录的信息

* vue Uncaught (in promise) undefined报错

降低路由的版本

```plain
npm i vue-router@3.0 -S
```

如果有修改父组件的内容，需要$emit来修改；如果父组件只是想调用子组件的方法，那么通过$ref来调用即可



## 显示图片

后台可能没有返回的图片，如果要展示图片需要先判断一下有否有图片的内容，如果没有那就显示默认的图片



* flex

flex可以和width同时使用

```
.cate_list{
  display: flex;
  flex-wrap: wrap;
  .list_item{
     width: 33.33%;
   }
}
```



## 节约性能

data中只存放要使用的数据，多余的数据需要过滤掉

webp格式的图片iPhone可能无法显示

## 内容加载完成显示显示{{}}

```vue
<style>
    [v-clock]:{
        display: none
    }
</style>
<template>
	<div id="app" v-clock>
        ....
    </div>
</template>
```



## 过滤器转换

```js
filters:{
    fmtNum(val){
        return ['壹','贰','叁','肆'][val]
    }
}
```



## 解析地址栏参数

```js
function getUrlParams(){
    let obj = {}
    // 判断是否有值
    if(!location.search) return obj
    let queryStrArr = location.search.replace('?', '').split('&')
    queryStrArr.forEach(item =>{
        let arr = item.split('=')
        obj[arr[0]] = arr[1]
    })
    return obj
}
```



## 星星评分效果

```vue
<template>
	<i class="iconfont" :class="item <= tempScore ? icon-star : icon-star1" v-for="item in count" @mouseenter="tempScore = item" @mouseleave="tempScore = score" @click="score = item"></i>
</template>
<script>
export default{
    data(){
        return{
            count:10, // 总分
            score: 5, // 得分
            tempScore: 5 // 临时得分
        }
    }
}
</script>
```



## 不能选择相同的查询条件

双重for循环才能判断查询条件有没有一样



## 给相同的名字加后缀

```js
// 同名时自动补位
let index=1;
let indexFlag = 0
arr.map((elm)=>{
  if(elm.name === this.listFrom.name){
    indexFlag = 1
  }else if(elm.name.search(new RegExp(eval("/"+ this.listFrom.name+'_[0-9]*'+'/')))!=-1){ // 匹配到有_的值
    index++;
    indexFlag = 2
  }
})
switch(indexFlag){
  case 1:
    this.listFrom.name = this.listFrom.name + '_1';
    break;
  case 2:
    this.listFrom.name = this.listFrom.name + '_' + index;
    break;
  default:
    break;
}
```



## 动态计算client Height

```js
data(){
    return{
        height: document.documentElement.clientHeight - 60
    }
}
```

## [上传文件需要携带请求头](https://www.cnblogs.com/yuyujuan/p/10867557.html)

```js
let config = {
    headers: {
      'Content-Type': 'multipart/form-data', // 记得修改携带的请求头
      'Authorization': this.token // 看情况需要
    }
  };
  this.axios.post(apidate.uploadEnclosure,formData,config)
    .then((response) => {
        if(response.data.info=="success"){
            this.$message({
                type: 'success',
                message: '附件上传成功!'
            });
        }
    })
```



## 删除table中的tr

需要找到他们的父节点移除才算移除成功

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .table,
    .table tr,
    .table td {
      border: 1px solid #000000;
    }

    .table td {
      width: 80px;
    }

    .table input {
      outline: none;
      border: 0;
      background-color: rgba(0, 0, 0, 0);
    }
  </style>
</head>

<body>
  <div class="container">
    <div id="tables">
      <div>
        <button onclick="deleteTr()">删除</button>
      </div>
      <table id="table" class="table" cellspacing="0">
        <tr>
          <td><input type="checkbox" class="checkbox"></td>
          <td>
            <span>11</span>
          </td>
          <td>
            <span>22</span>
          </td>
          <td>
            33
          </td>
        </tr>
        <tr>
          <td><input type="checkbox" class="checkbox"></td>
          <td>
            <span>22</span>
          </td>
          <td>
            <span>33</span>
          </td>
          <td>
            <canvas id="myCanvas" width="10" height="5" style="border:1px solid #000000;">
          </td>
        </tr>
      </table>
    </div>
  </div>
</body>
<script>
  function deleteTr() {
    var box = document.getElementsByClassName('checkbox');
    var len = box.length;
    var parent = null;
    for (var i = len - 1; i > -1; i--)
      if (box[i].checked) {
        parent = box[i].parentNode.parentNode;
        parent.remove();
      }
  }
</script>
</html>
```



## import和export

方式一：

```js
// 导出
export const LOGIN_NAME = 'login_user'
// 导入
import {LOGIN_NAME} from './aa.js'

```



方式二：

```js
// 导出
export default{
    
}
// 导入
import 
```



方式三：

```js
import * as Key from './aa.js' // 导出所有变量合并到key中
export default{
    data(){
        return{
            key: Key
        }
    }
}
```





## [导出excel对象数组为二维数组](https://www.bilibili.com/video/BV1SZ4y1H7dV?p=7)

## [canvas导出海报](https://www.bilibili.com/video/BV11f4y1R7GJ?p=68)

## [drag事件实现穿梭框](https://www.bilibili.com/video/BV137411J74J?p=71)

## [进度条](https://www.bilibili.com/video/BV137411J74J?p=75)

app页面

```vue
<template>
	<div id="app">
    	<div id="progress-bar"></div>
        <router-view></router-view>
    </div>
    </div>
</template>
<style>
    #progress-bar{
        height: 5px;
        background: blue;
        position: fixed;
        left: 0;
        top: 0;
        width: 100%;
        animation: grow 1s infinite forwards;
        display: none;
    }
    
    @keyframes grow{
        from:{
            width: 0;
        }
        to:{
            width: 100vw;
        }
    }
</style>
```

router页面

```js
const router = new VueRouter({ ... })
router.beforeEach((to, from, next) => {
  let bar = document.getElementById('progress-bar')
  if(bar) bar.style.display = 'block'
  setTimeOut(() => { next() })
})
router.afterEach((to, from) => {
  let bar = document.getElementById('progress-bar')
  if(bar) bar.style.display = 'none'
})
```



## 对象转字符串

```js
export const convertObj2Str = obj => {
    if(!obj) return ""
    return Object.keys(obj).map(item => {
        return item + '=' + obj[key]
    }).join('&')
}
```

## [音频可视化](https://www.bilibili.com/video/BV1Gv411C7vQ?p=88)

## [文件上传及进度显示](https://www.bilibili.com/video/BV1Gv411C7vQ?p=74)



## 文件预览

![](https://i.bmp.ovh/imgs/2021/07/1bd8749f77005478.png)

文件跳转预览

```js
//点击列进入预览查看
previewClick(row) {
  API.getPreviewAble(row.id,{
    onSucess: resp => {
      if(resp.data.errcode == 0){
        let that = this;
        let url = "";
        // 文件的地址
        url = this.kmsConfig.staticContextPath + this.kmsConfig.kmsFilePath + "/asset/preview/preview.html#diskId=" 
          + row.diskId + "&fileId=" + row.id + "&collected=" +row.collects
        let $windowOpen = window.open(url);
        //关闭新窗口回调方法
        let loop = setInterval(function() {     
          if($windowOpen  != null && $windowOpen.closed) {   
            clearInterval(loop);    
            //do something 在这里执行回调
            that.getUploadView(); // 调取刷新列表的接口
          }    
        }, 500); 
      }
    },
    onError: error => {
      if(error.response.data && error.response.data.errcode == 403){
         // 执行错误的内容
      }
    }
  })
},
```



## 下载完文件回到当前的页面

```js
api:
exportExcelLog: function (domainid, params, callback) {
    let url=`${contextPath}/authtime/domain/${domainid}/logger/export?operator=${params.operator}`
    window.open(url)
    callback();
},

// 调用对应的api
this.$api.exportExcelLog(domainid, this.searchdata,
  () => {
    this.$message.success('导出成功');
  })
```



## 在线拍照

```vue
<template>
  <div>
    <el-button @click="getOperationLogs">在线拍照</el-button>
    <div>
       <img :src="savePhoto" alt="" v-if="savePhoto">
    </div>
    <el-dialog
      title="在线拍照"
      :visible.sync="dialogVisible"
      :before-close="handleClose"
    >
      <!--图片展示-->
      <div class="shoot-area">
        <div class="left-take">
          <span>视频拍照</span>
          <video ref="video" width="160" height="125" autoplay></video>
          <el-button size="mini" class="btn" @click="photograph"
            >拍照</el-button
          >
        </div>
        <div class="right-show">
          <span>拍照照片</span>
          <canvas ref="canvas" width="160" height="125"></canvas>
        </div>
      </div>
      <!--canvas截取流-->
      <span slot="footer" class="dialog-footer">
        <el-button @click="callOff">取 消</el-button>
        <el-button type="primary" @click="onOk">确 定</el-button>
      </span>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: '',
  data() {
    return {
      dialogVisible: false,
      savePhoto: ''
    }
  },
  methods: {
    getOperationLogs() {
      const explorer = window.navigator.userAgent
      if (explorer.indexOf('MSIE') >= 0 || explorer.indexOf('Edge') >= 0) {
        alert('暂不支持IE浏览器')
      } else {
        this.dialogVisible = true
        this.callCamera()
      }
    },
    callCamera() {
      navigator.mediaDevices
        .getUserMedia({
          video: true,
        })
        .then((success) => {
          // 摄像头开启成功
          this.$refs['video'].srcObject = success
          // 实时拍照效果
          this.$refs['video'].play()
        })
        .catch((error) => {
          console.error('摄像头开启失败，请检查摄像头是否可用！')
          console.log(error)
        })
    },
    handleClose() {
      this.closeCamera()
    },
    onOk() {
      console.log('拍照的照片数据', this.savePhoto)
      this.dialogVisible = false
      this.closeCamera()
    },
    callOff() {
      this.dialogVisible = false
      this.closeCamera()
    },
    photograph() {
      let ctx = this.$refs['canvas'].getContext('2d')
      // 把当前视频帧内容渲染到canvas上
      ctx.drawImage(this.$refs['video'], 0, 0, 160, 125)
      // 转base64格式、图片格式转换、图片质量压缩
      let imgBase64 = this.$refs['canvas'].toDataURL('image/jpeg', 0.7)
      console.log('拍的图片-->',imgBase64)
      this.savePhoto = imgBase64
    },
    // 关闭摄像头
    closeCamera() {
      if (!this.$refs['video'].srcObject) return
      let stream = this.$refs['video'].srcObject
      let tracks = stream.getTracks()
      tracks.forEach((track) => {
        track.stop()
      })
      this.$refs['video'].srcObject = null
      console.log('关闭了')
    },
  },
}
</script>
<style lang='scss' scoped>
.shoot-area {
  width: 100%;
  height: 200px;
  display: -webkit-box;
  display: flex;
  flex-direction: row;
  .left-take {
    width: 182px;
    height: 200px;
    margin-right: 70px;
    padding: 12px 10px;
    background: #c5dae9;
    box-shadow: 0px 3px 3px 1px rgba(0, 0, 0, 0.4);
    & > span {
      height: 18px;
      color: #0b333c;
      font-weight: bold;
    }
    .btn {
      float: right;
    }
  }
  .right-show {
    background: #c5dae9;
    box-shadow: 0px 3px 3px 1px rgba(0, 0, 0, 0.4);
    width: 182px;
    height: 200px;
    margin-right: 70px;
    padding: 12px 10px;
    & > span {
      height: 18px;
      color: #0b333c;
      font-weight: bold;
    }
  }
  .el-dialog__body {
    padding: 30px 20px;
    color: #606266;
    font-size: 14px;
    word-break: break-all;
    background: pink;
  }
}
</style>
```



## 毛玻璃效果

### 有图片的毛玻璃

主要是通过背景图与filter搭配实现的效果

![](https://upload-images.jianshu.io/upload_images/4047814-cf2cd4ccff2140fd.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

```css
body, main::before{
    background: url("imgs/animals.jpg") 0 / cover fixed;
}
main{
    position: absolute;
    top: 0; bottom: 0;
    left: 0; right: 0;
    width: 800px;
    height: 500px;
    line-height: 2;
    margin: auto;
    border-radius: 5px;
    background: rgba(255, 255, 255, .3);
    box-shadow: 3px 3px 6px 3px rgba(0, 0, 0, .3);
    overflow: hidden;
}
main::before{
    content: '';
    position: absolute;
    top: 0; bottom: 0;
    left: 0; right: 0;
    filter: blur(20px);
    z-index: -1;
    margin: -30px;
}
```



### 没有图片的毛玻璃

通过backdrop-filter属性

可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素背后的所有元素，为了看到效果，必须使元素或其背景至少部分透明。



## 字符串指定字符高亮显示

```js
// 参数 source: 原始字符串
// 参数 keyword: 需要高亮的关键词
// 返回值：替换之后的高亮字符串
highlight (source, keyword) {
  // /searchContent/ 正则表达式中的一切内容都会当做字符串使用
  // 这里可以 new RegExp 方式根据字符串创建一个正则表达式
  // RegExp 是原生 JavaScript 的内置构造函数
  // 参数1：字符串，注意，这里不要加 //
  // 参数2：匹配模式，g 全局，i 忽略大小写
  const reg = new RegExp(keyword, 'gi')
  return source.replace(reg, `<span style="color: #3296fa">${keyword}</span>`)
},
    
// 使用
<van-cell
    icon="search"
    v-for="(item, index) in suggestions"
    :key="index"
    @click="onSearch(item)"
  >
    <div slot="title" v-html="highlight(item, keyword)"></div>
  </van-cell>
```



## 返回数据中的大数字问题

下载

```shell
npm i json-bigint
```

axios中使用

```js
import axios from 'axios'

import jsonBig from 'json-bigint'

var json = '{ "value" : 9223372036854775807, "v2": 123 }'

console.log(jsonBig.parse(json))

const request = axios.create({
  baseURL: 'http://ttapi.research.itcast.cn/', // 接口基础路径

  // transformResponse 允许自定义原始的响应数据（字符串）
  transformResponse: [function (data) {
    try {
      // 如果转换成功则返回转换的数据结果
      return jsonBig.parse(data)
    } catch (err) {
      // 如果转换失败，则包装为统一数据格式并返回
      return {
        data
      }
    }
  }]
})

export default request
```



## 放大缩小错位问题

一般都是写死了px或其他，可以尝试用百分比或rem代替



## application/x-www-form-urlencoded和application/json区别

**application/x-www-form-urlencoded编码类型的发送和接收**

窗体数据被编码为名称/值对

客户端：发送"test=I'm Egret"，浏览器按F12，Network中查看发送数据

![img](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTUuY25ibG9ncy5jb20vYmxvZy8xMDYyMTc0LzIwMTcwNi8xMDYyMTc0LTIwMTcwNjE2MTUwMDAyOTAwLTE1NDMxNzM0NTUucG5n.jpg)

 **application/json的发送和接收**

序列化后的 JSON 字符串

客户端：发送JSON格式字符串 '{"test":"I'm Client."}'

![img](https://bbsmax.ikafan.com/static/L3Byb3h5L2h0dHBzL2ltYWdlczIwMTUuY25ibG9ncy5jb20vYmxvZy8xMDYyMTc0LzIwMTcwNi8xMDYyMTc0LTIwMTcwNjE2MTU1NTQ2MjU5LTM0NjM3MTYxMS5wbmc=.jpg)



## 重置data中对象的数据

(不再需要自己手动写全部对象的字段再赋值)

```js
this.form = this.$options.data().form;
```



## 默认行为和事件冒泡

代码执行后跳到jQuery的方法中，需要用阻止默认行为或事件冒泡的方式处理





## MessageBox以async和await方式使用

```javascript
import { MessageBox } from 'element-ui';

// 删除
export const delMsg = (title='此操作将永久删除该文件, 是否继续?', tip='提示', confrimBtn='确定', cancelBtn='取消') => {
    return MessageBox.confirm(title, tip, {
        confirmButtonText: confrimBtn,
        cancelButtonText: cancelBtn,
        type: 'warning'
  })
}


// 文件中引入使用
import {delMsg} from '文件'
async del(){
  const res = await delMsg()
 	console.log(res) 
}
```



## 封装table插槽传值

### 封装的table

#### 方式一(推荐)

案例

![image-20220805115522278](https://gitee.com/yx102/pic/raw/master/img/202208051155406.png)

BaseTable.vue

```vue
<template>
    <div id="Wrap">
        <!-- 表格 -->
        <el-table height="100px" @selection-change="selectionChange" class="table" :data="tableData" :border="hasBorder"
            :row-class-name="tableRowClassName">
            <el-table-column type="selection" width="50" v-if="selectionShow"> </el-table-column>
            <!-- 序号 -->
            <el-table-column v-if="hasIndex" type="index" label="序号" header-align="center" align="center" width="80">
            </el-table-column>
            <!-- 其他 -->
            <template v-for="item in tableColumnOptions">
                <!-- 插槽列 -->
                <el-table-column v-if="item.columnType" :key="item.label" :prop="item.prop" :label="item.label"
                    :width="item.width" :header-align="item.headerAlign || 'center'" :align="item.align || 'center'">
                    <template slot-scope="{ row }">
                        <slot :name="item.soltName" :data="row"></slot>
                    </template>
                </el-table-column>
                <!-- 非插槽列 -->
                <el-table-column v-else :key="item.prop" :prop="item.prop" :label="item.label" :width="item.width"
                    :header-align="item.headerAlign || 'center'" :align="item.align || 'center'">
                </el-table-column>
            </template>
        </el-table>
        <!-- 分页器 -->
        <div class="pagination" v-if="paginationShow">
            <el-pagination :hide-on-single-page="isShowPagination" :page-sizes="[10, 20, 50, 100]"
                :current-page="currentPage" :page-size="pageSize" :total="tableDataTotal"
                layout="total, sizes, prev, pager, next, jumper" @size-change="handleSizeChange"
                @current-change="handleCurrentChange">
            </el-pagination>
        </div>
    </div>
</template>
<script type="text/ecmascript-6">
export default {
    name: "BaseTable",
    props: {
        // 表格数据
        tableData: {
            type: Array,
            default() {
                return [];
            },
        },
        // 表格列项
        tableColumnOptions: {
            type: Array,
            require: true,
            default() {
                return [];
            },
        },
        // 表格数据总量
        tableDataTotal: {
            type: Number,
            default() {
                return 0;
            },
        },
        // 是否具有索引
        hasIndex: {
            type: Boolean,
            default() {
                return true;
            },
        },
        // 是否显示边框
        hasBorder: {
            type: Boolean,
            default() {
                return false;
            },
        },
        // 是否显示选择框
        selectionShow: {
            type: Boolean,
            default() {
                return true;
            },
        },
        // 是否显示选分页器
        paginationShow: {
            type: Boolean,
            default() {
                return true;
            },
        },
    },
    data() {
        return {
            // 表格当前页数
            currentPage: 1,
            // 表格每页数量
            pageSize: 10,
        };
    },
    computed: {
        // 计算是否显示分页器
        isShowPagination() {
            const isShow = this.tableDataTotal === 0;
            return isShow;
        },
    },
    methods: {
        // 表格变色
        tableRowClassName({ row, rowIndex }) {
            if (rowIndex % 2 == 1) {
                return "color-row";
            }
        },
        // 修改当前页
        handleCurrentChange(val) {
            const params = {
                currentPage: val,
                pageSize: this.pageSize,
            };
            this.$emit("tableUpdate", params);
        },
        // 修改每页数量
        handleSizeChange(val) {
            const params = {
                currentPage: 1,
                pageSize: val,
            };
            this.$emit("tableUpdate", params);
        },
        // 选择框改变
        selectionChange(e) {
            this.$emit('selectionChange', e)
        }
    },
};
</script>
<style lang="less" scoped>
#Wrap {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    background-color: #fff;
    display: flex;
    flex-direction: column;

    .pagination {
        margin-top: auto;
        margin-left: auto;
    }

    .cell {
        text-align: center;

        #link {
            font-family: MicrosoftYaHei;
            color: #445af7;
            cursor: pointer;
        }

        #delete {
            color: #ff5b5b;
            margin-left: 35px;
            cursor: pointer;
        }
    }

    .color-row {
        background-color: rgb(243, 243, 243);
    }

    .el-table--border::after,
    .el-table--group::after,
    .el-table::before {
        content: '';
        position: absolute;
        background-color: transparent !important;
        z-index: 1;
    }
}
</style>
```

使用

```vue
<template>
  <div>
    <BaseTable :has-index="true" :has-border="false" :table-data="tableData" :table-data-total="tableData.length"
      :table-column-options="tableColumnOptions" @tableUpdate="tableUpdate" @selectionChange="selectionChange">
      <!-- 类型插槽 -->
      <template #tag="{ data }">
        <div class="tag">
          <el-tag type="success" v-if="data.type == 1">tag1</el-tag>
          <el-tag type="danger" v-if="data.type == 0">tag2</el-tag>
        </div>
      </template>
      <!-- 操作插槽 -->
      <template #operation="{ data }">
        <el-button @click="tableRowEdit(data)">编辑</el-button>
        <el-button @click="tableRowDelete(data)">删除</el-button>
      </template>
      <!-- 链接插槽 -->
      <template #link="{ data }">
         <el-link type="primary">查看</el-link>
      </template>
    </BaseTable>
  </div>
</template>

<script>
import BaseTable from '@/components/BaseTable.vue'
export default {
  name: 'Home',
  methods: {
    selectionChange(e) {
      console.log("选择框改变时：", e);
    },
    tableUpdate(e) {
      console.log("表格发生变化时", e);
    },
    tableRowEdit(e) {
      console.log("拿到此行的数据", e);
    },
    tableRowDelete(row){
      console.log("拿到刪除的數據", e)
    }
  },
  data() {
    return {
      //表格组件--模拟数据
      tableData: [
        { id: 201791074073, name: "张三", type: 1 },
        { id: 201791074071, name: "李四", type: 0 },
        { id: 201791074074, name: "张二", type: 0 },
        { id: 201791074074, name: "张二", type: 0 },
        { id: 201791074074, name: "张二", type: 1 },
      ],
      /**
       * 表格列项数据 (必传)
       * label 表格列项名称
       * prop: ''
       * width 列项宽度
       * align       内容对齐方式 (默认居中)
       * headerAlign 表头对齐方式 (默认居中)
       * columnType  是否开启插槽
       * soltName    插槽名
       */
      tableColumnOptions: [
        { label: "账号", prop: "id" },
        { label: "姓名", prop: "name" },
        { label: "tag", prop: "type", columnType: true, soltName: "tag" },
        { label: "特殊样式", columnType: true, soltName: "link" },
        { label: "操作", width: "300", columnType: true, soltName: "operation" },
      ],
    }
  },
  components: {
    BaseTable
  },
  mounted() { },
}
</script>
<style lang='less' scoped>
</style>
```



#### 方式二

可动态配置表格顶部的按钮以及右侧操作需要显示的内容，使用了插槽`slot name="action-bar" 和 slot name="action-row"`

```vue
<div class="table-view">
  <div ref="action-bar" class="action-bar">
    <slot name="action-bar" :selectedRowKeys="selectedRowKeys" :form="form" /> // 将table中选中的值和表单传到此处的插槽做另外的操作
  </div>
  <el-table
    ref="table"
    v-loading="loading"
    :data="list"
    :height="tableHeight"
    class="table"
    @selection-change="handleSelectionChange">
    <template v-if="list.length > 0">
     <div v-if="isShowSelection">
        <el-table-column type="selection" width="50" />
     </div>
      <el-table-column label="序号" width="50" align="center" type="index" />
      <el-table-column width="120" label="线索编号" align="center" prop="clueNumber" />
      <slot name="table-column-right" />
      <el-table-column label="操作" align="center" width="250" fixed="right" v-if="isTableRowAction">
        <template slot-scope="{ row }">
          <slot name="action-row" :row="row" />
        </template>
      </el-table-column>
    </template>
  </el-table>
</div>
```

### 使用

撤回按钮可以操作selection中的值，在封装table的之后给它传值了

源数据详情可以操作当前行的数据，在封装的时候传递了

```vue
<WaitList ref="waitIssueList" :clueNumber="clueNumber" :loadTableDataFn="loadDecisionList">
  <template #action-bar="{ selectedRowKeys }">
    <el-button @click="handleRemove(selectedRowKeys)">
      撤回
    </el-button>
  </template>
  <template #action-row="{ row }">
    <el-button type="text" @click="handleDetail(row)"> 源数据详情 </el-button>
  </template>
</WaitList>

<script>
import WaitList from '@/comp/WaitList.vue'
export default{
  components:{
    WaitList
  }
}
</script>
```



## 下载

### 下载excel二进制数据流返回原页面

```js
exportUser: function (callback) {
     let url=`下载的地址路径`
     window.open(url)
     callback();
 },
     
==========使用=============
this.$api.exportUser(() => {this.$message.success('导出成功')});
```



### 二进制流文件下载

将二进制流转换为blob`new Blob`

创建A标签，将要下载的文件链接赋值给href，将A标签插入body中，A标签点击事件触发下载

```javascript
downFile(){
  let token = localStorage.getItem('token')
  axios(baseUrl+'/factoryMakeData/exportDataToExcel', {
    params: this.query,
    responseType:'arraybuffer',
    headers: {
      Authorization: token,
      Accept: 'application/json',
      'Content-Type': 'application/json; charset=utf-8',
      withCredentials: true,
    },
  }).then(response => {
    console.log(response)
    let fileName = `制牌数据.xls`
    // 将二进制流转为blob
    const blob = new Blob([response.data], {type: 'application/octet-stream'})
    if (typeof window.navigator.msSaveBlob !== 'undefined') {
      // 兼容IE，window.navigator.msSaveBlob：以本地方式保存文件
      window.navigator.msSaveBlob(blob, decodeURI(fileName))
    } else {
      // 创建新的URL并指向File对象或者Blob对象的地址
      const blobURL = window.URL.createObjectURL(blob)
      // 创建a标签，用于跳转至下载链接
      const tempLink = document.createElement('a')
      tempLink.style.display = 'none'
      tempLink.href = blobURL
      tempLink.setAttribute('download', decodeURI(fileName))
      // 兼容：某些浏览器不支持HTML5的download属性
      if (typeof tempLink.download === 'undefined') {
        tempLink.setAttribute('target', '_blank')
      }
      // 挂载a标签
      document.body.appendChild(tempLink)
      tempLink.click()
      document.body.removeChild(tempLink)
      // 释放blob URL地址
      window.URL.revokeObjectURL(blobURL)
    }
  })
}
```



### 下载文件

点击下载请求接口，如果接口返回的是一个文件名称

```js
// 通用下载方法
export function download(fileName) {
	window.location.href = baseURL + "/common/download?fileName=" + encodeURI(fileName) + "&delete=" + true;// 将路径拼对即可(上面的只适用于当前做的项目)
}
```



### 下载zip包

![](https://i.bmp.ovh/imgs/2021/11/9d8ae5f85137c99a.png)

后端接口返回blob数据流下载zip包对应的js

```js
import axios from 'axios'
import { getToken } from '@/utils/auth'

const mimeMap = {
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  zip: 'application/zip'
}

const baseUrl = process.env.VUE_APP_BASE_API
export function downLoadZip(str) {
  var url = baseUrl + str
  axios({
    method: 'get',
    url: url,
    responseType: 'blob',
    headers: { 'Authorization': 'Bearer ' + getToken() }
  }).then(res => {
    resolveBlob(res, mimeMap.zip)
  })
}
/**
 * 解析blob响应内容并下载
 * @param {*} res blob响应内容
 * @param {String} mimeType MIME类型
 */
export function resolveBlob(res, mimeType) {
  const aLink = document.createElement('a')
  var blob = new Blob([res.data], { type: mimeType })
  // //从response的headers中获取filename, 后端response.setHeader("Content-disposition", "attachment; filename=xxxx.docx") 设置的文件名;
  var patt = new RegExp('filename=([^;]+\\.[^\\.;]+);*')
  var contentDisposition = decodeURI(res.headers['content-disposition'])
  var result = patt.exec(contentDisposition)
  var fileName = result[1]
  fileName = fileName.replace(/\"/g, '')
  aLink.style.display = 'none'
  aLink.href = URL.createObjectURL(blob)
  aLink.setAttribute('download', fileName) // 设置下载文件名称
  document.body.appendChild(aLink)
  aLink.click()
  URL.revokeObjectURL(aLink.href);//清除引用
  document.body.removeChild(aLink);
}
```

引入使用

```js
downLoadZip("/tool/gen/batchGenCode?tables=" + tableNames);
```



## 指令

### 可拖拽右侧弹窗

```js
export default {
    bind(el) {
        const dragDom = el.querySelector('.el-dialog');
        const lineEl = document.createElement('div');
        lineEl.style = 'width: 5px; background-color: blue; height: 80%; position: absolute; right: 0; top: 0; bottom: 0; margin: auto; z-index: 1; cursor: w-resize;';
        lineEl.addEventListener('mousedown',
            function (e) {
                // 鼠标按下，计算当前元素距离可视区的距离
                const disX = e.clientX - el.offsetLeft;
                // 当前宽度
                const curWidth = dragDom.offsetWidth;
                document.onmousemove = function (e) {
                    e.preventDefault(); // 移动时禁用默认事件
                    // 通过事件委托，计算移动的距离
                    const l = e.clientX - disX;
                    dragDom.style.width = `${curWidth + l}px`;
                };
                document.onmouseup = function (e) {
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            }, false);
        dragDom.appendChild(lineEl);
    }
}
```



### 可拖动弹窗高度

但底部有按钮的没有做自适应

```js
export default {
    bind(el) {
        const dragDom = el.querySelector('.el-dialog');
        const lineEl = document.createElement('div');
        lineEl.style = 'width: 6px; background: inherit; height: 10px; position: absolute; right: 0; bottom: 0; margin: auto; z-index: 1; cursor: nwse-resize;';
        lineEl.addEventListener('mousedown',
            function(e) {
                // 鼠标按下，计算当前元素距离可视区的距离
                const disX = e.clientX - el.offsetLeft;
                const disY = e.clientY - el.offsetTop;
                // 当前宽度 高度
                const curWidth = dragDom.offsetWidth;
                const curHeight = dragDom.offsetHeight;
                document.onmousemove = function(e) {
                    e.preventDefault(); // 移动时禁用默认事件
                    // 通过事件委托，计算移动的距离
                    const xl = e.clientX - disX;
                    const yl = e.clientY - disY
                    dragDom.style.width = `${curWidth + xl}px`;
                    dragDom.style.height = `${curHeight + yl}px`;
                };
                document.onmouseup = function(e) {
                    document.onmousemove = null;
                    document.onmouseup = null;
                };
            }, false);
        dragDom.appendChild(lineEl);
    }
}
```



### 可拖拽整个弹窗

```js
export default {
  bind(el, binding, vnode, oldVnode) {
    const value = binding.value
    if (value == false) return
    // 获取拖拽内容头部
    const dialogHeaderEl = el.querySelector('.el-dialog__header');
    const dragDom = el.querySelector('.el-dialog');
    dialogHeaderEl.style.cursor = 'move';
    // 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null);
    const sty = dragDom.currentStyle || window.getComputedStyle(dragDom, null);
    dragDom.style.position = 'absolute';
    dragDom.style.marginTop = 0;
    let width = dragDom.style.width;
    if (width.includes('%')) {
      width = +document.body.clientWidth * (+width.replace(/\%/g, '') / 100);
    } else {
      width = +width.replace(/\px/g, '');
    }
    dragDom.style.left = `${(document.body.clientWidth - width) / 2}px`;
    // 鼠标按下事件
    dialogHeaderEl.onmousedown = (e) => {
      // 鼠标按下，计算当前元素距离可视区的距离 (鼠标点击位置距离可视窗口的距离)
      const disX = e.clientX - dialogHeaderEl.offsetLeft;
      const disY = e.clientY - dialogHeaderEl.offsetTop;

      // 获取到的值带px 正则匹配替换
      let styL, styT;

      // 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px
      if (sty.left.includes('%')) {
        styL = +document.body.clientWidth * (+sty.left.replace(/\%/g, '') / 100);
        styT = +document.body.clientHeight * (+sty.top.replace(/\%/g, '') / 100);
      } else {
        styL = +sty.left.replace(/\px/g, '');
        styT = +sty.top.replace(/\px/g, '');
      };

      // 鼠标拖拽事件
      document.onmousemove = function (e) {
        // 通过事件委托，计算移动的距离 （开始拖拽至结束拖拽的距离）
        const l = e.clientX - disX;
        const t = e.clientY - disY;

        let finallyL = l + styL
        let finallyT = t + styT

        // 移动当前元素
        dragDom.style.left = `${finallyL}px`;
        dragDom.style.top = `${finallyT}px`;
      };

      document.onmouseup = function (e) {
        document.onmousemove = null;
        document.onmouseup = null;
      };
    }
  }
};
```



### 判断按钮是否有权限操作

```js
import store from '@/store'

export default {
  inserted(el, binding, vnode) {
    const { value } = binding
    const all_permission = "*:*:*";
    const permissions = store.getters && store.getters.permissions

    if (value && value instanceof Array && value.length > 0) {
      const permissionFlag = value

      const hasPermissions = permissions.some(permission => {
        return all_permission === permission || permissionFlag.includes(permission)
      })

      if (!hasPermissions) {
        el.parentNode && el.parentNode.removeChild(el) // 如果不存在当前按钮就在html中移除
      }
    } else {
      throw new Error(`请设置操作权限标签值`)
    }
  }
}
```



### 一次性注册所有的指令

存放指令的文件directive.js

```js
export default {
  test: {
    bind(el, binding, vnode, oldVnode) {
      console.log('test')
    },
  },
  demo:{
    bind(el, binding, vnode, oldVnode) {
      console.log('demo')
    },
  }
};
```

注册所有指令的文件install.js

```js
import directives from "./directives"
export default{
    install(Vue){
        Object.keys(directives).forEach(key => {
            Vue.directive(key, directives[key])
        })
    }
}
```

在main文件中注册

```js
import installDirective from './install'
Vue.use(installDirective)
```



## formData的方式提交表单

表单格式传递的数据输出的formData看不到真实的值，只能在接口中或则自己拼凑的过程中知道会传递哪些值

### 方式一

```js
const params = {
    id: this.$route.query.id,
    recoverLon: this.postionMap.lng,
    recoverLat: this.postionMap.lat
  }
  const formData = new FormData()
  for (let k in params) {
    formData.append('' + k, params[k])
  }
  try {
    const { msg } = await locationCorrect(formData) // 接口传递formData参数
    this.$toast(msg)
  } catch (err) {
    console.log('locationCorrect', err)
  }
```

### 方式二

```js
const formData = new FormData()
formData.append('id', this.$route.query.id)
formData.append('recoverLon', this.postionMap.lng)
formData.append('recoverLat', this.postionMap.lat)
try {
  const { msg } = await locationCorrect(formData) // 接口传递formData参数
  this.$toast(msg)
} catch (err) {
  console.log('locationCorrect', err)
}
```



## formData传递文件流binary

### 单文件

![](https://i.bmp.ovh/imgs/2021/12/418bb7e8aad0e1a3.png)

```js
const params = {
  avatarFile: this.avatarFile[0].file
}
const formData = new FormData()
for (let k in params) {
  formData.append('' + k, params[k])
}
// 此时的formData经过加工之后的avatarFile就是文件流
```



### 多文件

![](https://i.bmp.ovh/imgs/2021/12/257976980d97f909.png)

```js
const formData = new FormData()
this.fileList.forEach(item => {
  formData.append('files', item.file)
})
// 此时的formData经过加工之后就会形成files的数组
```



## h5拨号发短信

```html
// 在<head>里面加上
<meta name="format-detection" content="telephone=yes"/>

<body>
  // 拨打电话
  <a href="tel:168-1686-16888">168-1686-16888</a>
  // 发短信
  <a href="sms:10086?body=短信内容"></a>
</body>
```



## h5实现扫描二维码

```shell
npm i jsqr
```



这个插件需要使用https才能启动，否则不生效，可以在vue.config.js中开启https

```js
devServer:{
  https:true
}
```



```vue
<template>
  <div class="page">
    <img src="@/assets/back.png" class="close-icon" @click.stop="close" />
    <div class="qr-scanner qrcode-stream-wrapper" id="canvasbox">
      <video v-show="isVideo" class="qrcode-stream-camera"></video>
      <canvas id="canvas" class="qrcode-stream-camera" v-show="!isVideo"></canvas>
      <div class="scan-box">
        <div class="line"></div>
      </div>
    </div>
  </div>
</template>

<script>
import jsQR from "jsqr";
export default {
  data () {
    return {
      isVideo: true,
      code: "",
      videoEl: null
    };
  },
  mounted () {
    let src = this.GetQueryString('baseSrc')
    if (src) this.src = src
    let videoEl = document.querySelector("video");
    this.videoEl = videoEl
    this.onload();
  },
  methods: {
    GetQueryString (name) {
      var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
      var r = window.location.search.substr(1).match(reg);
      if (r != null) return unescape(r[2]);
      return null;
    },
    async onload () {
      const videoEl = this.videoEl
      let _this = this;
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        console.log("不支持 enumerateDevices() .");
        alert('无法获取摄像功能')
      }
      const devices = (await navigator.mediaDevices.enumerateDevices()).filter(
        ({ kind }) => kind === "videoinput"
      );
      const rearCamera = devices[devices.length - 1];
      const constraints = {
        audio: false,
        video: {
          width: { min: 360, ideal: 640, max: 1920 },
          height: { min: 240, ideal: 480, max: 1080 },
          facingMode: "environment",
          deviceId: { exact: rearCamera.deviceId }
        }
      };
      navigator.mediaDevices.getUserMedia(constraints)
        .then(function (stream) {
          if (videoEl.srcObject !== undefined) {
            videoEl.srcObject = stream;
          } else if (videoEl.mozSrcObject !== undefined) {
            videoEl.mozSrcObject = stream;
          } else if (window.URL.createObjectURL) {
            videoEl.src = window.URL.createObjectURL(stream);
          } else if (window.webkitURL) {
            videoEl.src = window.webkitURL.createObjectURL(stream);
          } else {
            videoEl.src = stream;
          }
          videoEl.setAttribute("playsinline", true); // required to tell iOS safari we don't want fullscreen
          videoEl.onloadedmetadata = function () {
            videoEl.play()
            requestAnimationFrame(_this.tick)
          }
          // videoEl.play();
          // requestAnimationFrame(_this.tick);
        }).catch(function (err) {
          // alert('该浏览器不支持扫码,请更换浏览器')
          console.log(err.name + ": " + err.message)
        });
    },

    tick () {
      const videoEl = this.videoEl
      let canvasElement = document.getElementById("canvas");
      let canvas = canvasElement.getContext("2d");
      let canvasbox = document.getElementById("canvasbox");
      if (videoEl.readyState === videoEl.HAVE_ENOUGH_DATA) {
        canvasElement.hidden = false;
        canvasElement.height = videoEl.videoHeight;
        canvasElement.width = videoEl.videoWidth;
        canvas.drawImage(
          videoEl,
          0,
          0,
          videoEl.videoWidth,
          videoEl.videoHeight
        );
        let imageData = canvas.getImageData(
          canvasbox.getBoundingClientRect().left,
          canvasbox.getBoundingClientRect().top,
          canvasbox.offsetWidth,
          canvasbox.offsetHeight
        );
        let code = jsQR(imageData.data, imageData.width, imageData.height, {
          inversionAttempts: "attemptBoth",
        });
        if (code) {
          if (code.data) {
            if (this.src) {
              window.location.href = `${this.src}?code=${code.data}`;
            } else {
              alert('扫描成功')
              console.log(code.data)
            }
          }
        }
      }
      requestAnimationFrame(this.tick);
    },

    close () {
      alert('返回')
    },
  },
  beforeDestroy () {
    this.videoEl = null
  }
};
</script>

<style >
.qrcode-stream-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 0;
}

.page {
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
.close-box {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  text-align: left;
}
.qrcode-stream-camera {
  width: 100%;
  height: 100%;

  display: block;
  object-fit: cover;
}

.qr-scanner {
  background-image: linear-gradient(
      0deg,
      transparent 24%,
      rgba(32, 255, 77, 0.1) 25%,
      rgba(32, 255, 77, 0.1) 26%,
      transparent 27%,
      transparent 74%,
      rgba(32, 255, 77, 0.1) 75%,
      rgba(32, 255, 77, 0.1) 76%,
      transparent 77%,
      transparent
    ),
    linear-gradient(
      90deg,
      transparent 24%,
      rgba(32, 255, 77, 0.1) 25%,
      rgba(32, 255, 77, 0.1) 26%,
      transparent 27%,
      transparent 74%,
      rgba(32, 255, 77, 0.1) 75%,
      rgba(32, 255, 77, 0.1) 76%,
      transparent 77%,
      transparent
    );
  background-size: 3rem 3rem;
  background-position: -1rem -1rem;
  background-color: #111;
}

.qr-scanner .scan-box {
  width: 86vw;
  height: 50vh;
  max-height: 70vh;
  max-width: 90vh;
  border: 1px solid green;
  position: absolute;
  left: 50%;
  top: 36%;
  transform: translate(-50%, -30%);
  overflow: hidden;
  z-index: 99;
}

.qr-scanner .line {
  height: 100%;
  width: 100%;
  background-image: linear-gradient(
    180deg,
    rgba(0, 255, 51, 0) 95%,
    #00ff33 120%
  );
  border-radius: 10px;
  transform: translateY(-100%);
  animation: radar-beam 2s infinite;
  animation-timing-function: cubic-bezier(0.53, 0, 0.43, 0.99);
  animation-delay: 1s;
}

@keyframes radar-beam {
  0% {
    transform: translateY(-100%);
  }

  100% {
    transform: translateY(0);
  }
}

.close-icon {
  height: 20px;
  width: 20px;
  position: fixed;
  left: 16px;
  top: 20px;
  z-index: 999;
}
</style>
```



## h5识别上传图片的二维码

```shell
npm i jsqr
```



```vue
<template>
  <div>
    <input type="file" @change="toQr" accept="image/*" />
  </div>
</template>

<script>
import jsQR from 'jsqr'
export default {
  name: '',
  data() {
    return {}
  },
  methods: {
    toQr(e) {
      const file = e.target.files[0]
      if (window.FileReader) {
        const fr = new FileReader()
        fr.readAsDataURL(file)
        fr.onloadend = e => {
          const base64Data = e.target.result
          this.base64ToqR(base64Data)
        }
      }
    },
    base64ToqR(data) {
      const c = document.createElement('canvas')
      const ctx = c.getContext('2d')

      const img = new Image()
      img.src = data
      img.onload = () => {
        // 一定要给canvas设置宽度和高度，不然识别不出来！！！
        c.width = img.width
        c.height = img.height
        ctx.drawImage(img, 0, 0, img.width, img.height)
        const imageData = ctx.getImageData(0, 0, img.width, img.height)
        const code = jsQR(imageData.data, imageData.width, imageData.height, {
          inversionAttempts: 'attemptBoth'
        })
        if (code) {
          alert('识别成功', code.data)
          console.log(code.data)
        } else {
          alert('识别错误')
        }
      }
    }
  }
}
</script>
<style lang='less' scoped>
</style>
```



## 合并单元格

elementui中使用`span-method`方法进行合并

后端返回的数据必须是一条条的list，不能是组合好的tree

计算一个需要合并的数组出来，执行的之后遍历将数据渲染上去

![](https://i.bmp.ovh/imgs/2021/12/b5c779eac9eeb67f.png)

```javascript
<script>
export default {
  data() {
    return {
      spanArr: [],
    };
  },
  methods: {
    getData() {
      // 1. 请求完数据之后要进行合并得到需要合并的数组
      this.tableData = data;
      this.rowMerge(this.tableData, this.spanArr, "zpph");
    },

    objectSpanMethod({ row, column, rowIndex, columnIndex }) {
      if (columnIndex === 0) {
        if (this.spanArr[rowIndex]) {
          return {
            rowspan: this.spanArr[rowIndex],
            colspan: 1,
          };
        } else {
          return {
            rowspan: 0,
            colspan: 0,
          };
        }
      }
    },
      
    // tableData：需要合并的数据， spanArr：合并后单元格的数组， type：需要合并的key
    rowMerge(tableData,spanArr, type){ 
      let contactDot = 0;
      let flag = false
      tableData.forEach((item,index) => {
          if(index===0){
              spanArr.push(1)
          }else{
              if(item[type] === tableData[index-1][type]){// 此处是跟tableData的上一条数据进行比较，返回的list必须是排序好的
                  spanArr[contactDot] += 1;
                  spanArr.push(0)
              }else{
                  contactDot = index
                  spanArr.push(1)
              }
          }
      })
    }
  },
};
</script>
```



## 复杂表头下载

```shell
npm i xlsx
```

方法一：直接抓取dom来下载

```js
const el = this.$refs.exportTable.$el;
const wb = xlsx.utils.table_to_book(el, { raw: true });
xlsx.writeFile(wb, `统计分析${getNowDate()}.xls`);
```





## 刷新重新加载token

小程序嵌套的h5的项目不能用sessionStorage来存储token(token会超时)，一般都是在首页刷新之后自己发请求获取token

此时就要在router.beforeEach中做判断，而且登录是获取token值，如果已经有token再请求登录接口会报403错误

```js
// 全局导航守卫
router.beforeEach(async (to, from, next) => {
  if (!store.state.user.token) {
     await store.dispatch('login', { code: openId })
  }
  next()
})

// store.js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    token: ''
  },
  mutations: {
    SET_TOKEN(state, val){
      state.token = val
    }
  },
  actions: {
    login({commit}){
      // 发送请求
      commit('SET_TOKEN', token)
    }
  },
  modules: {
  }
})
```



## [路由权限](https://juejin.cn/post/6844903478880370701#heading-8)

后端开启了history模式刷新会出现404的状态

404路由提前放到静态路由中

请求回来的后端路由addRoutes

```js
import router from './router'
import store from './store'
import { Message } from 'element-ui'
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'
import { getToken } from '@/utils/auth'

NProgress.configure({ showSpinner: false })
const whiteList = ['/login', '/auth-redirect', '/bind', '/register']

router.beforeEach((to, from, next) => {
  NProgress.start()
  if (getToken()) {
    to.meta.title && store.dispatch('settings/setTitle', to.meta.title)
    /* has token*/
    if (to.path === '/login') {
      next({ path: '/' })
      NProgress.done()
    } else {
      if (store.getters.roles.length === 0) {
        // 判断当前用户是否已拉取完user_info信息
        store.dispatch('GetInfo').then(() => {
          store.dispatch('GenerateRoutes').then(accessRoutes => {
            // 根据roles权限生成可访问的路由表
            router.addRoutes(accessRoutes) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成
          })
        }).catch(err => {
            store.dispatch('LogOut').then(() => {
              Message.error(err)
              next({ path: '/' })
            })
          })
      } else {
        next()
      }
    }
  } else {
    // 没有token
    if (whiteList.indexOf(to.path) !== -1) {
      // 在免登录白名单，直接进入
      next()
    } else {
      next(`/login?redirect=${to.fullPath}`) // 否则全部重定向到登录页
      NProgress.done()
    }
  }
})

router.afterEach(() => {
  NProgress.done()
})
```



## [按钮权限](https://panjiachen.github.io/vue-element-admin-site/zh/guide/essentials/permission.html#指令权限)

方式一：将可以用的按钮权限key存到sessionStorage中，然后在按钮的地方直接通过v-if判断显示和隐藏

```js
<el-button v-if="permission.user_add">添加</el-button>
```



[方式二](https://github.com/PanJiaChen/vue-element-admin/blob/master/src/directive/permission/permission.js)：将可用的按钮权限存到sessionStorage中，通过指令的方式来控制按钮的显示和隐藏

permission.js

```js
 /**
 * v-hasPermi 操作权限处理
 * Copyright (c) 2019 epms
 */
 
import store from '@/store'

export default {
  inserted(el, binding, vnode) {
    const { value } = binding
    const roles = store.getters && store.getters.roles

    if (value && value instanceof Array) {
      if (value.length > 0) {
        const permissionRoles = value

        const hasPermission = roles.some(role => {
          return permissionRoles.includes(role)
        })

        if (!hasPermission) {
          el.parentNode && el.parentNode.removeChild(el)
        }
      }
    } else {
      throw new Error(`need roles! Like v-permission="['admin','editor']"`)
    }
  }
}
```

注册指令

使用

```js
<el-button v-hasPermi="['decision:decisionInformation:getHeadStatistics']">添加</el-button>
```



## 等待promise执行后再设置

程序可以等待promise的执行，但是不会等待map的执行，虽然在控制台打印该结果是有设置进去的值，但是data中没有这个值，因此需要Promise来处理

```js
async getPatrolInfo(){
    try{
      const { data } = await loadGetPatrolInfo(this.params)
      // 处理图片回显
      const res = await Promise.all(data.patrolSecurityRelationList.map(async (item: AnyObject) => {
        if(item.images){
          item.base64Url = await loadGetBase64(item.images)
        }
        return item
      }))
      this.patrolInfo = {
        ...data,
        patrolSecurityRelationList: res
      }
    }catch(err){
      console.log('loadGetPatrolInfo', err)
    }
  }
```



## el-upload添加limit的+还显示

添加limit限制图片张数后上传按钮还显示，暂时通过js的方式来控制css

```javascript
img1(val) {
  if (val.length) {
    document.getElementsByClassName('el-upload--picture-card')[0].style.display = 'none' // 隐藏
  } else {
    document.getElementsByClassName('el-upload--picture-card')[0].style.display = 'inline-block'  // 显示
  }
},
```



## 循环的表单规则不生效

循环的数组必须要在form绑定的对象中，如果不在form绑定的对象中会报`Error:please transfer a valid prop path to form item`错

```vue
<div v-for="(s, i) in dialogForm.patrolSecurityRelationList" :key="s.key + 'A'">
  <el-form-item
    label="发现安全问题"
    :prop="'patrolSecurityRelationList.' + i + '.patrolSecurity'" // for中绑定的值，v-model绑定的值
    :rules="[{
      required: true, message: '安全问题不能为空', trigger: 'blur'
    }]"
  >
    <el-select v-model="s.patrolSecurity" clearable class="w500">
      <el-option
        v-for="item in securityProblemList"
        :key="item.dictValue"
        :label="item.dictLabel"
        :value="item.dictValue"
      />
    </el-select>
  </el-form-item>
</div>
```



## 上传图片获取内容

```vue
<template>
	<el-upload
    :action="uploadImgUrl"
    :headers="headers"
    list-type="picture-card"
    :limit="1"
    :before-upload="checkType"
    :on-success="data => handleUploadSuccess(data, s)" // 获得上传的内容和for当前的项
    :on-remove="() => handleRemove(s)" // 需要使用箭头函数，否则在执行成功的时候也会触发这个函数的执行
    accept="image/*"
  >
    <i class="el-icon-plus" />
  </el-upload>
</template>
```



## 图片预览

### 小程序

```js
// 预览照片
handlePreview(url: string) {
  uni.previewImage({
    current: url,
    urls: [url]
  })
}
```

### h5-vant

van-image-preview

```html
<van-image-preview v-model="show" :images="images" @change="onChange"></van-image-preview>
```

### pc

preview-src-list

```html
 <el-image 
    style="width: 100px; height: 100px"
    :src="url" 
    :preview-src-list="srcList">
  </el-image>
```



## 网站变灰

```css
filter: grayscale(100%);
```



## 轮播图

### 使用Swiper

采用watch+nextTick来实现轮播图的滚动

watch：监测到数据回来的时候准备初始化轮播图结构，nextTick是在下次 DOM 更新循环结束之后执行延迟回调

```vue
<template>
  <div class="swiper-container" ref="cur">
    <div class="swiper-wrapper">
      <div
        class="swiper-slide"
        v-for="carousel in list"
        :key="carousel.id"
      >
        <img :src="carousel.imgUrl" />
      </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>
    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
  </div>
</template>

<script>
//引入Swiper
import Swiper from "swiper";
export default {
  name: "Carsousel",
  props: ["list"],
  watch: {
    list: {
      //立即监听：不管你数据有没有变化，我上来立即监听一次
      //为什么watch监听不大list：因为这个数据从来没有发生变化（数据是父亲给的，父亲给的时候就是一个对象，对象里面该有的数据都是有的）
      immediate: true,
      handler() {
        //只能监听到数据已经有了，但是v-for动态渲染结构我们还是没有办法确定的，因此还是需要用nextTick
        this.$nextTick(() => {
          var mySwiper = new Swiper(this.$refs.cur, {
            loop: true,
            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
              //点击小球的时候也切换图片
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>
```



### 封装一opacity

![image-20220830153102259](https://gitee.com/yx102/pic/raw/master/img/image-20220830153102259.png)

通过opacity来显示哪张

```vue
<template>
    <div class='carousel' @mouseenter="stop" @mouseleave="start">
        <ul class="carousel-body">
            <li class="carousel-item" v-for="(item, i) in list" :key="item.id" :class="{ fade: i === curr }">
                <RouterLink to="/">
                    <img :src="item.imgUrl">
                </RouterLink>
            </li>
        </ul>
        <a href="javascript:;" class="carousel-btn prev" @click="toggle(-1)"><i
                class="iconfont icon-angle-left"></i></a>
        <a href="javascript:;" class="carousel-btn next" @click="toggle(1)"><i
                class="iconfont icon-angle-right"></i></a>
        <div class="carousel-indicator">
            <span v-for="(item, i) in list" :key="item.id" @click="handleIndicator(i)"
                :class="{ active: i === curr }"></span>
        </div>
    </div>
</template>

<script>
export default {
    name: 'Carousel'
}
</script>
<script setup>
import { ref, watch, onUnmounted } from 'vue'
const props = defineProps({
    list: {
        type: Array,
        default: () => []
    },
    duration: {
        type: Number,
        default: 3000
    }
})

const curr = ref(0)
const toggle = (val) => {
    const newVal = curr.value + val
    if (newVal < 0) {
        curr.value = props.list.length - 1
        return
    } else if (newVal > props.list.length - 1) {
        curr.value = 0
        return
    }
    curr.value = newVal
}
const handleIndicator = (i) => {
    curr.value = i
}

// 自动轮播
let timer = ref(null)
const autoPlayFn = () => {
    stop()
    timer = setInterval(() => {
        curr.value++
        if (curr.value >= props.list.length)
            curr.value = 0
    }, props.duration)
}

const start = () => {
    stop()
    if (props.list.length)
        autoPlayFn()
}

const stop = () => {
    clearInterval(timer)
}

watch(() => props.list, (newVal) => {
    // 有数据&开启自动播放，才调用自动播放函数
    if (newVal && props.list.length)
        autoPlayFn()
}, { immediate: true })

// 组件消耗，清理定时器
onUnmounted(() => {
    clearInterval(timer)
})

</script>
<style scoped lang="scss">
.carousel {
    width: 100%;
    height: 100%;
    min-width: 300px;
    min-height: 150px;
    position: relative;

    .carousel {
        &-body {
            width: 100%;
            height: 100%;
        }

        &-item {
            width: 100%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            transition: opacity 0.5s linear;

            &.fade {
                opacity: 1;
                z-index: 1;
            }

            img {
                width: 100%;
                height: 100%;
            }
        }

        &-indicator {
            position: absolute;
            left: 0;
            bottom: 20px;
            z-index: 2;
            width: 100%;
            text-align: center;

            span {
                display: inline-block;
                width: 12px;
                height: 12px;
                background: rgba(0, 0, 0, 0.2);
                border-radius: 50%;
                cursor: pointer;

                ~span {
                    margin-left: 12px;
                }

                &.active {
                    background: #fff;
                }
            }
        }

        &-btn {
            width: 44px;
            height: 44px;
            background: rgba(0, 0, 0, .2);
            color: #fff;
            border-radius: 50%;
            position: absolute;
            top: 228px;
            z-index: 2;
            text-align: center;
            line-height: 44px;
            opacity: 0;
            transition: all 0.5s;

            &.prev {
                left: 20px;
            }

            &.next {
                right: 20px;
            }
        }
    }

    &:hover {
        .carousel-btn {
            opacity: 1;
        }
    }
}
</style>
```

### 封装二translateX

![image-20220830153349068](https://gitee.com/yx102/pic/raw/master/img/image-20220830153349068.png)

使用translateX改变位移来显示不同内容

```vue
<template>
    <HomePanel ref="target" title="热门品牌" sub-title="国际经典 品质保证">
        <template v-slot:right>
            <a href="javascript:;" class="iconfont icon-angle-left prev" :class="{ disabled: curr == 0 }"
                @click="toggle(-1)"></a>
            <a href="javascript:;" class="iconfont icon-angle-right next" :class="{ disabled: curr == 1 }"
                @click="toggle(1)"></a>
        </template>
        <div class="box" ref="box">
            <ul class="list" :style="{ transform: `translateX(${-curr * 1240}px)` }">
                <li v-for="item in 10" :key="item">
                    <RouterLink to="/">
                        <img src="http://zhoushugang.gitee.io/erabbit-client-pc-static/uploads/brand_goods_1.jpg" alt="">
                    </RouterLink>
                </li>
            </ul>
        </div>
    </HomePanel>
</template>
  
<script>
export default {
    name: 'HomeBrand',
}
</script>
<script setup>
import HomePanel from './home-panel.vue'
import { ref } from 'vue'

const curr = ref(0)

const toggle = (val) => {
    curr.value = curr.value + val
}
</script>
<style scoped lang='scss'>
.home-panel {
  background: #f5f5f5
}

.iconfont {
  width: 20px;
  height: 20px;
  background: #ccc;
  color: #fff;
  display: inline-block;
  text-align: center;
  margin-left: 5px;
  background: $mainColor;

  &::before {
      font-size: 12px;
      position: relative;
      top: -2px
  }

  &.disabled {
      background: #ccc;
      cursor: not-allowed;
  }
}

.box {
  display: flex;
  width: 100%;
  height: 345px;
  overflow: hidden;
  padding-bottom: 40px;

  .list {
      width: 200%;
      display: flex;
      transition: all 1s;

      li {
          margin-right: 10px;
          width: 240px;

          &:nth-child(5n) {
              margin-right: 0;
          }

          img {
              width: 240px;
              height: 305px;
          }
      }
  }
}
</style>
```



## 放大镜

![image-20220901174545355](https://gitee.com/yx102/pic/raw/master/img/202209011745657.png)

### 写法一

```vue
<template>
  <div class="spec-preview">
    <img :src="imgObj.imgUrl" />
    <div class="event" @mousemove="handler"></div>
    <div class="big">
      <img :src="imgObj.imgUrl" ref="big"/>
    </div>
    <!-- 遮罩层 -->
    <div class="mask" ref="mask"></div>
  </div>
</template>

<script>
export default {
  name: "Zoom",
  props: ["skuImageList"],
  data() {
    return {
      currentIndex:0
    }
  },
  computed:{
    imgObj(){
      return this.skuImageList[this.currentIndex]||{}
    }
  },
  mounted(){
    //全局事件总线：获取兄弟组件传递过来的索引值
    this.$bus.$on('getIndex',(index)=>{
        //修改当前响应式数据
        this.currentIndex = index;
    })
  },
  methods: {
    handler(event) {
      let mask = this.$refs.mask; // 中间绿色的遮罩
      let big = this.$refs.big; // 右侧放大的框
      let left = event.offsetX - mask.offsetWidth/2; // 计算鼠标相对左侧盒子的距离，event.offsetX鼠标相对当前盒子左侧的距离；mask.offsetWidth/2：鼠标始终在遮罩盒子的中间位置
      let top = event.offsetY - mask.offsetHeight/2; // 计算鼠标相对上方盒子的距离，event.offsetY鼠标相对当前盒子上方的距离；mask.offsetHeight/2：鼠标始终在遮罩盒子的中间位置
      //约束范围
      if(left <=0) left = 0; // 左侧触碰边界
      if(left >=mask.offsetWidth) left = mask.offsetWidth; // 右侧边界距离
      if(top<=0)top = 0; // 上方临界点
      if(top>=mask.offsetHeight) top = mask.offsetHeight; // 下方临界点
      //修改元素的left|top属性值
      mask.style.left = left+'px';
      mask.style.top = top +'px';
      big.style.left = - 2 * left+'px'; // 放大效果是鼠标移动的两倍，css中也设置了200%
      big.style.top = -2 * top +'px'; // 放大效果是鼠标移动的两倍
    },
  },

};
</script>

<style lang="less">
.spec-preview {
  position: relative;
  width: 400px;
  height: 400px;
  border: 1px solid #ccc;

  img {
    width: 100%;
    height: 100%;
  }

  .event {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 998;
  }

  .mask {
    width: 50%;
    height: 50%;
    background-color: rgba(0, 255, 0, 0.3);
    position: absolute;
    left: 0;
    top: 0;
    display: none;
  }

  .big {
    width: 100%;
    height: 100%;
    position: absolute;
    top: -1px;
    left: 100%;
    border: 1px solid #aaa;
    overflow: hidden;
    z-index: 998;
    display: none;
    background: white;

    img {
      width: 200%;
      max-width: 200%;
      height: 200%;
      position: absolute;
      left: 0;
      top: 0;
    }
  }

  .event:hover ~ .mask,
  .event:hover ~ .big {
    display: block;
  }
}
</style>
```



### 写法二

```vue
<template>
    <div class="goods-image">
        <div class="large" v-show="show" :style="{ backgroundImage: `url(${list[curr]})`, backgroundPositionX: -position.left*2+'px', backgroundPositionY: -position.top*2+'px' }"></div>
        <div class="middle" ref="target">
            <img :src="list[curr]" alt="">
            <div class="layer" v-show="show" :style="{ left: position.left+'px', top: position.top+'px' }"></div>
        </div>
        <ul class="small">
            <li v-for="(item, i) in list" :key="i" @mouseenter="curr = i" :class="{ active: curr === i }">
                <img :src="item" alt="">
            </li>
        </ul>
    </div>
</template>
<script setup>
import { reactive, ref, watch } from 'vue';
import { useMouseInElement } from "@vueuse/core";
const props = defineProps({
    list: {
        type: Array,
        default: () => []
    }
})

const curr = ref(0)

// 鼠标位置
const target = ref(null);
const { elementX, elementY, isOutside } = useMouseInElement(target);
const show = ref(false)
const position = reactive({
    left: 0,
    top: 0
})
watch([elementX, elementY, isOutside], () => {
    show.value = !isOutside.value

    // 左右临界值
    // 控制X轴方向的定位 0-200 之间
    if (elementX.value < 100) position.left = 0
    else if (elementX.value > 300) position.left = 200
    else position.left = (elementX.value - 100)
    // 上下临界值
    if (elementY.value < 100) position.top = 0
    else if (elementY.value > 300) position.top = 200
    else position.top = (elementY.value - 100)
})

</script>
<style scoped lang="scss">
.goods-image {
    width: 480px;
    height: 400px;
    position: relative;
    display: flex;
    z-index: 500;

    .large {
        position: absolute;
        top: 0;
        left: 412px;
        width: 400px;
        height: 400px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        background-repeat: no-repeat;
        background-size: 800px 800px;
        background-color: #f8f8f8;
    }

    .middle {
        width: 400px;
        height: 400px;
        background: #f5f5f5;
        position: relative;
        cursor: move;

        .layer {
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, .2);
            left: 0;
            top: 0;
            position: absolute;
        }
    }

    .small {
        width: 80px;

        li {
            width: 68px;
            height: 68px;
            margin-left: 12px;
            margin-bottom: 15px;
            cursor: pointer;

            &:hover,
            &.active {
                border: 2px solid $mainColor;
            }
        }
    }
}
</style>
```





## 跳转路由取消请求

`axios.js`：二次封装的axios

在请求拦截器中添加当前页面所有的请求到vuex中用作记录

在响应拦截器中判断时候取消请求而走请求错误的代码

```js
import axios from "axios";
import store from "../store";

// 默认请求的基础地质
// axios.defaults.baseURL = "";

// 请求拦截器【需要授权的 API ，必须在请求头中使用 `Authorization` 字段提供 `token` 令牌】
axios.interceptors.request.use(function(config) {
  //   config.headers.Authorization = window.sessionStorage.getItem('token')
  config.cancelToken = new axios.CancelToken(function(cancel) {
    store.commit("pushToken", { cancelToken: cancel });
  });
  return config;
});

// 响应拦截器，直接输出数据信息，并且直接在拦截器中实现请求失败
axios.interceptors.response.use(
  function(response) {
    // 直接获取到data数据对象
    return response.data;
  },
  function(error) {
    if (axios.isCancel(error)) {
      // 为了终结promise链 就是实际请求 不会走到.catch(rej=>{});这样就不会触发错误提示之类了。
      return new Promise(() => {});
    } else {
      return Promise.reject(error);
    }
  }
);

export default axios;
```



`store.js`

记录当前请求的接口，在页面发生跳转的时候执行对应的方法

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    cancelTokenArr: [] // 取消请求token数组
  },
  mutations: {
    pushToken (state, payload) {
      state.cancelTokenArr.push(payload.cancelToken)
    },
    clearToken (state) {
      state.cancelTokenArr.forEach(e => {
        e && e()
      })
      state.cancelTokenArr = []
    }
  },
  actions: {
  },
  modules: {
  }
})
```



`router.js`

在路由跳转前执行请求当前页的所有请求

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Home from '../views/Home.vue'
import store from '../store'
Vue.use(VueRouter)

const routes = [
  {
    path: '/',
    redirect: '/app-vue2'
  },
  {
    path: '/app-vue2',
    name: 'Home',
    component: Home
  },
  {
    path: '/app-vue3',
    name: 'About',
    component: () => import(/* webpackChunkName: "about" */ '../views/About.vue')
  }
]

const router = new VueRouter({
  routes
})

router.beforeEach(function (to, from, next) {
  store.commit('clearToken') // 取消请求
  next()
})

export default router
```



## 表单有提示能自动定位到提示

自动跳转到第一个错误提示中

```js
submitForm(formName) {
  this.$refs[formName].validate((valid, msg) => {
    if (valid) {
      alert("submit!");
    } else {
      // 重点！！
      this.$nextTick(() => {
        const el = this.$refs.ruleForm.$el.querySelectorAll('.el-form-item__error')[0];
        el.scrollIntoView({ block: 'center', behavior: 'smooth' });
      });
      return false;
    }
  });
},
```



## 营销组件

### 刮刮乐

```vue
<template>
    <div class="scratch">
        <div class="scratch_wp" :style="{ width: scratch.width + 'px', height: +scratch.height + 'px' }">
            <canvas ref="canvas" class="scratch_canvas"
                :style="{ width: scratch.width + 'px', height: scratch.height + 'px' }"
                @mousedown="mousedown" @mousemove="mousemove" @mouseup="mouseup"></canvas>
            <div class="scratch_txt"
                :style="{ lineHeight: scratch.canvasHeight + 'px', color: scratch.awardTxtColor, fontSize: scratch.awardTxtFontSize }">
                {{ scratch.awardTxt }}</div>
        </div>
    </div>
</template>

<script>
export default {
    name: 'Scratch',
    data() {
        return {
            ctx: null, //画布上下文
            isStart: false, // 是否开始擦除
            lastX: 0,
            lastY: 0,
            minX: '',
            minY: '',
            maxX: '',
            maxY: '',
            isStart: false,
        }
    },
    components: {},
    methods: {
        mousedown(e) {
            this.isStart = true
            if (!this.isStart) return
            const pos = this.drawRect(e.offsetX, e.offsetY)
            this.ctx.clearRect(pos[0], pos[1], pos[2], pos[2])
        },
        mousemove(e) {
            if (!this.isStart) return
            const pos = this.drawRect(e.offsetX, e.offsetY)
            this.ctx.clearRect(pos[0], pos[1], pos[2], pos[2])
        },
        mouseup() {
            if (!this.isStart) return
            const { minX, minY, maxX, maxY } = this
            const { canvasWidth, canvasHeight } = this.scratch
            // 判断擦除的总面积为70%下定论是中奖还是没有中奖
            if (maxX - minX > .7 * canvasWidth && maxY - minY > .7 * canvasHeight) {
                this.callBackFn && this.callBackFn()
            }
            this.isStart = false
        },
        restart() {
            this.init()
            this.lastX = 0
            this.lastY = 0
            this.minX = ''
            this.minY = ''
            this.maxX = ''
            this.maxY = ''
            this.isStart = true
        },
        drawRect(x, y) {
            const { r, minX, minY, maxX, maxY } = this
            const x1 = x - r > 0 ? x - r : 0
            const y1 = y - r > 0 ? y - r : 0
            // 这几个值用于计算用户画的面积是多少
            if ('' != minX) {
                this.minX = minX > x1 ? x1 : minX
                this.minY = minY > y1 ? y1 : minY
                this.maxX = maxX > x1 ? maxX : x1
                this.maxY = maxY > y1 ? maxY : y1
            } else {
                this.minX = x1
                this.minY = y1
                this.maxX = x1
                this.maxY = y1
            }
            this.lastX = x1
            this.lastY = y1

            return [x1, y1, 2 * r]
        }
    },
    mounted() {
        const { canvasWidth, canvasHeight, imageResource, maskColor } = this.scratch
        const canvas = this.$refs.canvas
        this.ctx = canvas.getContext('2d')
        this.ctx.clearRect(0, 0, canvasWidth, canvasHeight)
        if (imageResource) {
            const img = new Image()
            img.src = imageResource
            img.onload = () => {
                this.ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight)
            }
        } else {
            this.ctx.fillStyle = maskColor;
            this.ctx.fillRect(0, 0, canvasWidth, canvasHeight)
        }
    },
    props: {
        scratch: {
            type: Object,
            required: true,
            default: () => { }
        },
        r: {
            type: Number,
            default: 4
        },
        callBackFn: {
            type: Function,
        }
    }
}
</script>
<style lang='less' scoped>
.scratch {
    .scratch_wp {
        position: relative;
        margin: 0 auto;

        .scratch_canvas {
            margin: 0 auto;
            background: transparent;
        }

        .scratch_txt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            text-align: center;
            pointer-events: none;
            z-index: -1;
        }
    }
}
</style>
```

使用

```vue
<template>
  <div>
    <Scratch :scratch="scratch" :callBackFn="callBackFn"/>
  </div>
</template>

<script>
import Scratch from '@/components/Scratch.vue'
export default {
  name: 'Home',
  data() {
    return {
      scratch: {
        canvasWidth: 200,   //画布宽带
        canvasHeight: 100,  //画布高度
        imageResource: require('../assets/placeholder.png'), //遮罩层图片
        r: 4, //笔触半径
        awardTxt: '中大奖', //底部抽奖文字奖项
        awardTxtColor: "#1AAD16", //底部抽奖文字颜色
        awardTxtFontSize: "24px", //底部抽奖文字大小
        maskColor: "red",  //没有图片遮罩层颜色
      }
    }
  },
  components: {
    Scratch
  },
  methods: {
    callBackFn(){
      // 传递给子组件的函数内容
      this.$message.success('中獎了')
    }
  },
  mounted() { },
}
</script>
<style lang='scss' scoped>
</style>
```



### 九宫格抽奖

![image-20220808172931274](https://gitee.com/yx102/pic/raw/master/img/202208081729404.png)

GridCard.vue

```vue
<template>
    <div class="gridcard">
        <div :class="['gridcard_item', item.isBack ? 'back' : '', item.isMove ? 'move' : '']"
            v-for="(item, idx) in card" :key="idx" @click="onClick(item)">
            <div class="gridcard_front">
                <img src="../assets/card_front.png" />
            </div>
            <div class="gridcard_back">
                <img src="../assets/marquee_btn.png" />
            </div>
        </div>
        <el-button type="primary" @click="reset" class="reset_btn">重新抽奖</el-button>
    </div>
</template>

<script>
export default {
    name: 'GridCard',
    data() {
        return {
            isFlip: false,
            card: []
        }
    },
    components: {},
    methods: {
        onClick(item) {
            if (!this.isFlip) return
            if (!item.isBack)
                item.isBack = !item.isBack
            this.$emit('prize', item)
            this.runAsync(600).then(() => {
                this.callBackFn && this.callBackFn()
            })
        },
        // 图片刚开始的动画
        start() {
            this.card = JSON.parse(JSON.stringify(this.list))
            const { card } = this
            this.runAsync(100)
                // .then(() => {
                //     for (let i = 0; i < 3; i++) {
                //         card[i].isBack = true
                //     }
                //     this.card = card
                //     return this.runAsync(200)
                // }).then(() => {
                //     for (let i = 3; i < 6; i++) {
                //         card[i].isBack = true
                //     }
                //     this.card = card
                //     return this.runAsync(200)
                // }).then(() => {
                //     for (let i = 6; i <= 8; i++) {
                //         card[i].isBack = true
                //     }
                //     this.card = card
                //     return this.runAsync(800)
                // }).then(() => {
                //     for (let i = 0; i < 9; i++) {
                //         card[i].isBack = false
                //     }
                //     this.card = card
                //     return this.runAsync(400)
                // })
                // 重置翻牌
                .then(() => {
                    for (let i = 0; i < 9; i++) {
                        card[i].isBack = false
                    }
                    this.card = card
                    return this.runAsync(300)
                })
                // 往中间叠放
                .then(() => {
                    for (let i = 0; i < 9; i++) {
                        card[i].isMove = true
                    }
                    this.card = card
                    return this.runAsync(500)
                })
                // 向原来的地方展开
                .then(() => {
                    for (let i = 0; i < 9; i++) {
                        card[i].isMove = false
                    }
                    this.card = card
                    this.isFlip = true
                })
        },
        reset() {
            this.isFlip = false
            this.runAsync(800).then(() => {
                this.$emit('reload')
                this.start()
            })
        },
        /**
         * runAsync 延迟返回 promise 方法
         * @param  {Number} time 延迟时间
         * @return {type}   返回Promise对象
         */
        runAsync(time) {
            return new Promise(function (resolve, reject) {
                const timer = setTimeout(function () {
                    resolve()
                    clearTimeout(timer)
                }, time)
            })
        }
    },
    mounted() {
        this.start()
    },
    props: {
        list: {
            type: Array,
            default: () => []
        },
        callBackFn: {
            type: Function,
        }
    },
}
</script>
<style lang='less' scoped>
/**
 * perspective： 400px属性，焦距影响其子元素，会影响整个子元素大空间，perspective(400px) 影响元素本身
 */
.gridcard {
    margin: 0 20;
    position: relative;
    height: 410px;

    .gridcard_item {
        position: absolute;
        width: 115px;
        height: 115px;
        -webkit-transform-style: preserve-3d;
        transform-style: preserve-3d;
        -webkit-transition: all 0.8s ease-in-out;
        transition: all 0.8s ease-in-out;

        img {
            display: block;
            width: 100%;
            height: 100%;
        }

        .gridcard_front,
        .gridcard_back {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            font-size: 20px;
            color: #fff;
            text-align: center;
            line-height: 115px;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            z-index: 1;
        }

        .gridcard_back {
            -webkit-transform: rotateY(180deg) translateZ(0);
            transform: rotateY(180deg) translateZ(0);
            background: #1E9FD9;
        }

        &.back {
            -webkit-transform: perspective(1000px) rotateY(-180deg) translateZ(0);
            transform: perspective(1000px) rotateY(-180deg) translateZ(0);
        }

        &.move {
            z-index: 3;
            -webkit-transition: all 0.4s linear;
            transition: all 0.4s linear;
        }

        &:nth-child(1) {
            top: 0;
            left: 0;

            &.move {
                -webkit-transform: translate3d(120px, 120px, 0);
                transform: translate3d(120px, 120px, 0);
            }
        }

        &:nth-child(2) {
            top: 0;
            left: 120px;

            &.move {
                -webkit-transform: translate3d(0, 120px, 0);
                transform: translate3d(0, 120px, 0);
            }
        }

        &:nth-child(3) {
            top: 0;
            left: 240px;

            &.move {
                -webkit-transform: translate3d(-120px, 120px, 0);
                transform: translate3d(-120px, 120px, 0);
            }
        }

        &:nth-child(4) {
            top: 120px;
            left: 0;

            &.move {
                -webkit-transform: translate3d(120px, 0, 0);
                transform: translate3d(120px, 0, 0);
            }
        }

        &:nth-child(5) {
            top: 120px;
            left: 120px;
        }

        &:nth-child(6) {
            top: 120px;
            left: 240px;

            &.move {
                -webkit-transform: translate3d(-120px, 0, 0);
                transform: translate3d(-120px, 0, 0);
            }
        }

        &:nth-child(7) {
            top: 240px;
            left: 0;

            &.move {
                -webkit-transform: translate3d(120px, -120px, 0);
                transform: translate3d(120px, -120px, 0);
            }
        }

        &:nth-child(8) {
            top: 240px;
            left: 120px;

            &.move {
                -webkit-transform: translate3d(0, -120px, 0);
                transform: translate3d(0, -120px, 0);
            }
        }

        &:nth-child(9) {
            top: 240px;
            left: 240px;

            &.move {
                -webkit-transform: translate3d(-120px, -120px, 0);
                transform: translate3d(-120px, -120px, 0);
            }
        }
    }

    .reset_btn {
        position: absolute;
        bottom: 0;
    }
}
</style>
```

使用

```vue
<template>
  <GridCard :list="card" @prize="prize" @reload="init"/>
</template>

<script>
import GridCard from '@/components/GridCard.vue'
export default {
  name: 'Home',
  data() {
    return {
      card: []
    }
  },
  components: {
    GridCard
  },
  methods: {
    callBackFn() {
      // this.$message.success('中獎了')
      alert('需要执行的内容')
    },
    prize(item){
      this.$message.success(item.award)
    },
    init(){
      let arr = []
      const m = Math.floor(Math.random()*8)+1
      for(let i = 0; i < m; i++){
        arr.push(
          { inlineStyle: '', isBack: false, isMove: false, award: '谢谢惠顾' },
        )
      }
      arr.push(
        { inlineStyle: '', isBack: false, isMove: false, award: '一等奖' },
      )
      for(let j = 0; j < 8 - m; j++){
        arr.push(
          { inlineStyle: '', isBack: false, isMove: false, award: '谢谢惠顾' },
        )
      }

      this.card = arr
    }
  },
  created() {
    this.init()
  },
}
</script>
<style lang='scss' scoped>
</style>
```



## 批量注册组件

1.需要在`components`文件中新建一个 `index.js`文件

2.导入vue `import Vue from 'vue'`

3.使用`require.context()`方法

4.在min.js中导入index.js `import '@/components/index.js'`

```js
webpack方式
// 批量导入需要使用一个函数 require.context(dir,deep,matching)
// 参数：1. 目录  2. 是否加载子目录  3. 加载的正则匹配
const importFn = require.context('./', false, /\.vue$/)
// 匹配到的文件名数组
// console.log('查看匹配到的文件名数组', importFn.keys()) 
export default {
  install (app) {
  	// 批量注册全局组件
    // 遍历文件名数组
    importFn.keys().forEach(item => {
      // 导入函数根据文件名，导入文件内容
      const component = importFn(item).default
      // console.log(component)
      // 根据导入的组件文件，实现自动全局注册
      app.component(component.name, component)
    })
  }
}

vite方式
// 导入 lib 下面的 所有 .vue文件
const files = import.meta.globEager("/src/components/lib/*.vue");

// 匹配到的文件名数组
export default {
  install(app) {
    // 遍历文件名数组
    Object.keys(files).forEach((item) => {
      // 导入函数根据文件名，导入文件内容
      const component = files[item]?.default;
      // console.log(component)
      // 根据导入的组件文件，实现自动全局注册
      app.component(component.name, component);
    });
  },
};

```





## 404 页面的路由配置

需要使用正则来匹配(放到所有路由的最后面!!!)

```js
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue'),
  },
  {
    path: '/:catchAll(.*)',
    name: '/404',
    component: () => import('../views/404.vue'),
  },
]

const router = createRouter({
  history: createWebHistory(process.env.BASE_URL),
  routes,
})

export default router
```



## [懒加载图片](https://gitee.com/yx102/vite-erabbit/blob/master/src/components/lib/index.js)

封装

```js
import defaultImg from '@/assets/images/200.png'
// 指令
const defineDirective = (app) => {
  // 图片懒加载指令
  app.directive('lazy', {
    mounted (el, binding) {
      const observer = new IntersectionObserver(([{ isIntersecting }]) => {
        if (isIntersecting) {
          observer.unobserve(el)
          el.onerror = () => {
              el.src = defaultImg
          }  
          el.src = binding.value
        }
      }, {
        threshold: 0.01
      })
      observer.observe(el)
    }
  })
}
```

注册

```js
export default {
  install (app) {
     defineDirective(app)
  }
}
```

使用

要用`v-lazy`，用`:lazy`不生效

```vue
<img alt="" v-lazy="cate.picture">
```



## [懒加载页面组件](https://vueuse.org/core/useIntersectionObserver/)

当滚动到当前可视区域的时候才会触发请求加载数据

下载依赖

```shell
npm i @vueuse/core@4.9.0
```

hooks/index.js

```js
// hooks 封装逻辑，提供响应式数据。
import { useIntersectionObserver } from "@vueuse/core";
import { ref } from "vue";
// 数据懒加载函数
export const useLazyData = (apiFn, data) => {
  // 需要
  // 1. 被观察的对象
  // 2. 不同的API函数
  const target = ref(null);
  const result = ref([]);
  const { stop } = useIntersectionObserver(
    target,
    async ([{ isIntersecting }], observerElement) => {
      if (isIntersecting) {
        stop();
        const res = await apiFn(data)
        result.value = res.result
      }
    },// 配置选项，相交的比例大于0就触发
    {
      threshold: 0
    }
  );
  // 返回--->数据（dom,后台数据）
  return { target, result };
};

```

使用

target需要绑定到可视组件中，goods为请求后返回的数据

```vue
<template>
  <div class="home-new" ref="target">
      <!-- 面板内容 -->
      <ul class="goods-list">
        <li v-for="item in goods" :key="item.id">
          <RouterLink :to="`/product/${item.id}`">
            <img :src="item.picture" alt="">
            <p class="name ellipsis">{{item.name}}</p>
            <p class="price">&yen;{{item.price}}</p>
          </RouterLink>
        </li>
      </ul>
</template>
<script setup>
import { useLazyData } from '@/hooks'
import { getGoods } from '@/api/home'

const {target, result: goods} = useLazyData(getGoods)

</script>
```

## 转换base64

```js
export const getBase64 = (file) => {
  return new Promise(function (resolve, reject) {
    let reader = new FileReader();
    let imgResult = "";
    reader.readAsDataURL(file);
    reader.onload = function () {
      imgResult = reader.result;
    };
    reader.onerror = function (error) {
      reject(error);
    };
    reader.onloadend = function () {
      resolve(imgResult);
    };
  });
}
```



## 文件流下载

```js
export const downloadFile = (item) => {
  this.api.post(global_.downloadUrl, item, {
    responseType: 'blob'
  }).then((data) => {
    var blob = new Blob([data], {
      type: 'application/actet-stream;charset=utf-8'
    });
    var downloadElement = document.createElement('a');
    var href = window.URL.createObjectURL(blob); //创建下载的链接
    downloadElement.style.display = 'none';
    downloadElement.href = href;
    downloadElement.download = item.name; //下载后文件名
    document.body.appendChild(downloadElement);
    downloadElement.click(); //点击下载
    document.body.removeChild(downloadElement); //下载完成移除元素
    window.URL.revokeObjectURL(href); //释放掉blob对象
  });
}
```



注册element plus





## axios 搭配 ts 封装且全局挂载

```js
main.js
import axios from './http'

// 全局挂载axios
app.config.globalProperties.$axios = axios

http.ts
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios'
import { ElLoading } from 'element-plus'

let loading: any

const startLoading = () => {
  interface Options {
    lock: boolean;
    text: string;
    background: string;
  }

  const options: Options = {
    lock: true,
    text: '加载中...',
    background: 'rgba(0,0,0,0.7)',
  }
  loading = ElLoading.service(options)
}

const endLoading = () => {
  loading.close()
}

// 请求拦截
axios.interceptors.request.use((config: AxiosRequestConfig) => {
  // 加载
  startLoading()
  return config
})

// 响应拦截
axios.interceptors.response.use(
  (response: AxiosResponse<any>) => {
    // 结束loading
    endLoading()
    return response
  },
  (error) => {
    // 结束loading
    endLoading()
    // 错误提醒
    return Promise.reject(error)
  }
)

export default axios
```



## defineProps

```js
<script setup>
    const props = defineProps({
      showHeader: {
        type: Boolean,
        default: false
      }
    })
</script>
```



## defineEmits(ts)

有传参和没传参两种方式的传递

```js
<script setup>
interface EmitsType {
  (e: 'update: pagenum', val: number): void
  (e: 'closed'): void
}
const emit = defineEmits<EmitsType>()

const handleCurrentChange = (val: number) => {
  emit('update: pagenum', {
    pagenum: 1,
    pagesize: val
  })
}

const closed = () => {
  emit('closed')
}
</script>
```



## 使用element-plus(ts)

`plugins/element-plus.ts`

```ts
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import { App } from 'vue'

export default {
  install (app: App) {
    app.use(ElementPlus, { size: 'small', zIndex: 2000 })
  }
}
```

`plugins/element-plus-icon.ts`

```ts
import * as ElementPlusIconsVue from '@element-plus/icons-vue'
import { App } from 'vue'
export default {
  install (app: App) {
    for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
      app.component(key, component)
    }
  }
}
```



引入使用

```ts
import ElementPlus from './plugins/element-plus'
import ElementPlusIconsVue from './plugins/element-plus-icon'
createApp(App).use(ElementPlus).use(ElementPlusIconsVue).mount('#app')
```



## PC加载更多

页面滚到到组件可视区域时，配合使用`useIntersectionObserver`监测

```vue
<template>
    <div class="infinite-loading" ref="container">
        <div class="loading" v-if="props.loading">
            <span class="img"></span>
            <span class="text">正在加载...</span>
        </div>
        <div class="none" v-if="props.finished">
            <span class="img"></span>
            <span class="text">亲，没有更多了</span>
        </div>
    </div>
</template>
<script>
export default {
    name: 'InfiniteLoading'
}
</script>
<script setup>
import { useIntersectionObserver } from '@vueuse/core';
import { ref } from 'vue';
const props = defineProps({
    loading: {
        type: Boolean,
        default: false
    },
    finished: {
        type: Boolean,
        default: false
    },
})

const emit = defineEmits()
const container = ref(null)
useIntersectionObserver(container, ([{isIntersecting}], dom) => {
    if(isIntersecting){
        if(props.loading === false && props.finished === false){
            emit('infinite')
        }
    }
},{
    threshold: 0
})
</script>
<style scoped lang='scss'>
.infinite-loading {
    .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 200px;

        .img {
            width: 50px;
            height: 50px;
            background: url('http://erabbit.itheima.net/img/load.88daf935.gif') no-repeat center / contain;
        }

        .text {
            color: #999;
            font-size: 16px;
        }
    }

    .none {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 200px;

        .img {
            width: 200px;
            height: 134px;
            background: url(../../assets/images/none.png) no-repeat center / contain;
        }

        .text {
            color: #999;
            font-size: 16px;
        }
    }
}
</style>
```



## 一维数组转二维数组

```js
 const group = (array = [], subGroupLength = 0) => {
   let index = 0;
   const newArray = [];
   while (index < array.length) {
     newArray.push(array.slice(index, index += subGroupLength));
   }
   return newArray;
 }
 console.log(group(data, 3))
```



传递一个需要传参的函数给另一个函数使用

```js
import { useLazyData } from '@/hooks'
const { target, result } = useLazyData(() => findBrand(10))
```



## 将组件封装成插件

### loading插件

loading.vue

```vue
<template>
  <div class="loading-container" v-show="isShow">
    <div class="loading"></div>
    <p class="title">{{title}}</p>
 </div>
</template>

<script>
export default {
  name: 'Loading',
  data() { 
    return {
      title: '正在加载',
      isShow: false
    }
  },
  components:{},
  methods:{},
  mounted() {},
}
</script>
<style lang='scss' scoped>
.loading-container{
  width: 200px;
  height: 200px;
  border-radius: 20px;
  background: rgba($color: #000000, $alpha: 0.5);
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  .loading{
    width: 100px;
    height: 100px;
    border-radius: 50%;
    border: 5px solid #fff;
    margin: 20px auto;
    border-right-color: #409eff;
    animation: loading 2s linear infinite;
  }
  .title{
    text-align: center;
    color: #fff;
  }

  @keyframes loading {
    from{
      transform: rotate(0deg);
    }
    to{
      transform: rotate(360deg);
    }
  }
}
</style>
```

index.js

```javascript
import Loading from './Loading.vue'

export default {
    install: function(Vue, Options){
        // Vue.component(Loading.name, Loading)
        
        // 1. 根据组件生成一个构造函数
        let LoadingContructor = Vue.extend(Loading)
        // 2.根据构造函数创建实例对象
        let LoadingInstance = new LoadingContructor()
        // 3.随便创建一个标签(元素)
        let oDiv = document.createElement('div')
        // 4.将创建好的标签添加到界面上
        document.body.appendChild(oDiv)
        // 5.将创建好的实力对象挂载到创建好的元素上
        LoadingInstance.$mount(oDiv)

        // 添加初始化值
        if(Options && Options.title !== null && Options.title !== undefined){
            LoadingInstance.title = Options.title
        }
        // 添加全局方法
        Vue.showLoading = function(){
            LoadingInstance.isShow = true
        }
        Vue.hideLoading = function(){
            LoadingInstance.isShow = false
        }
        // 添加实例方法
        Vue.prototype.$showLoading = function(){
            LoadingInstance.isShow = true
        }
        Vue.prototype.$hideLoading = function(){
            LoadingInstance.isShow = false
        }
    }
}
```

在main.js中注册使用

```js
import Loading from './plugin/loading'
Vue.use(Loading)
```



### $confirm的方式使用组件

Confirm.vue

```vue
<template>
  <div class="confirm" :class="{ fade }">
    <div class="wrapper">
      <div class="header">
        <h3>{{ props.title }}</h3>
        <a href="JavaScript:;" class="iconfont icon-close-new"></a>
      </div>
      <div class="body">
        <i class="iconfont icon-warning"></i>
        <span>{{ props.text }}</span>
      </div>
      <div class="footer">
        <Button size="mini" type="gray" @click="cancel">取消</Button>
        <Button size="mini" type="primary" @click="submit">确认</Button>
      </div>
    </div>
  </div>
</template>
  <script>
export default {
  name: 'Confirm'
}
</script>
<script setup>
import Button from './button.vue'
import { ref, onMounted } from 'vue';
const props = defineProps({
  title: {
    type: String,
    default: '温馨提示'
  },
  text: {
    type: String,
    default: '您确认从购物车删除该商品吗？'
  },
  cancelCallback: Function,
  submitCallback: Function
})

// 对话框默认隐藏
const fade = ref(false)
// 组件渲染完毕后
onMounted(() => {
  // 过渡效果需要在元素创建完毕后延时一会加上才会触发
  setTimeout(() => {
    fade.value = true
  }, 0)
})
// 取消
const cancel = () => {
  // 其他事情
  props.cancelCallback()
}
// 确认
const submit = () => {
  // 其他事情
  props.submitCallback()
}
</script>
  <style scoped lang="scss">
  .confirm {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 8888;
    background: rgba(0, 0, 0, .5);
  
    .wrapper {
      width: 400px;
      background: #fff;
      border-radius: 4px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
  
      .header,
      .footer {
        height: 50px;
        line-height: 50px;
        padding: 0 20px;
      }
  
      .body {
        padding: 20px 40px;
        font-size: 16px;
  
        .icon-warning {
          color: $priceColor;
          margin-right: 3px;
          font-size: 16px;
        }
      }
  
      .footer {
        text-align: right;
  
        .button {
          margin-left: 20px;
        }
      }
  
      .header {
        position: relative;
  
        h3 {
          font-weight: normal;
          font-size: 18px;
        }
  
        a {
          position: absolute;
          right: 15px;
          top: 15px;
          font-size: 20px;
          width: 20px;
          height: 20px;
          line-height: 20px;
          text-align: center;
          color: #999;
  
          &:hover {
            color: #666;
          }
        }
      }
    }
  }
  </style>
```

Confirm.js

```js
import { createVNode, render } from 'vue'
import Confirm from './confirm.vue'

// 准备div
const div = document.createElement('div')
div.setAttribute('class', 'confirm-container')
document.body.appendChild(div)

// 该函数渲染Confirm组件，标题和文本
// 函数的返回值是promise对象
export default ({ title, text }) => {
  return new Promise((resolve, reject) => {
    const submitCallback = () => {
      render(null, div)
      resolve('confirm')
    }
    const cancelCallback = () => {
      render(null, div)
      reject('cancel')
    }
    // 1. 渲染组件
    // 2. 点击确认按钮，触发resolve同时销毁组件
    // 3. 点击取消按钮，触发reject同时销毁组件
    const vnode = createVNode(Confirm, { title, text, submitCallback, cancelCallback })
    render(vnode, div)
  })
}
```

挂载全局index.js

```js
import Confirm from "./Confirm";

// 匹配到的文件名数组
export default {
  install(app) {
    // 如果你想挂载全局的属性，能够通过组件实例调用的属性   this.$message
    app.config.globalProperties.$message = Message; // 原型函数
    app.config.globalProperties.$confirm = Confirm; // 原型函数
  },
};
```



## 类似data使用reactive

```vue
<script>
import {reactive, toRefs} from 'vue'
    const state = reactive({
        visible: false,
        form: {
            name: ''
        }
    })
    
    const { visible, form } = toRefs(state)
</script>
```

